{
  "name": "Coloredlist",
  "tagline": "A Tornado Tutorial App",
  "body": "### Table of Contents\r\n\r\n* [Introduction](#introduction)\r\n* [Getting Started](#getting-started)\r\n  * [Virtual Environment](#virtual-environment)\r\n  * [Installing Packages](#installing-packages)\r\n* [Creating the App](#creating-the-app)\r\n  * [The Main Application](#the-main-application)\r\n  * [Templates](#templates)\r\n* [Creating the List](#creating-the-list)\r\n  * [List URL Mapping](#list-url-mapping)\r\n  * [In Memory Storage](#in-memory-storage)\r\n  * [Import UUID](#import-uuid)\r\n  * [List Template](#list-template)\r\n  * [List Handler](#list-handler)\r\n* [Edit and Delete List Items](#edit-and-delete-list-items)\r\n  * [List Item URL Mapping](#list-item-url-mapping)\r\n  * [List Item Handler](#list-item-handler)\r\n  * [Importing Javascript](#importing-javascript)\r\n  * [Edit Template](#edit-template)\r\n  * [AJAX](#ajax)\r\n* [Persistent Storage](#persistent-storage)\r\n  * [pymongo](#pymongo)\r\n  * [Setting Up Database](#setting-up-database)\r\n  * [Make Database](#make-database)\r\n  * [Using Database](#using-database)\r\n  * [List Template with New Data Structure](#list-template-with-new-data-structure)\r\n* [Structuring the App](#structuring-the-app)\r\n  * [Static Content](#static-content)\r\n  * [Template Inheritance](#template-inheritance)\r\n  * [Handlers Module](#handlers-module)\r\n  * [App Settings](#app-settings)\r\n  * [DB Settings](#db-settings)\r\n  * [URL Patterns](#url-patterns)\r\n  * [Final Structure](#final-structure)\r\n* [Styling the App](#styling-the-app)\r\n  * [Basic CSS](#basic-css)\r\n* [User Authentication](#user-authentication)\r\n  * [Login Form](#login-form)\r\n  * [Login and Logout Handlers](#login-and-logout-handlers)\r\n  * [Authentication URL Patterns](#authentication-url-patterns)\r\n  * [Authentication AJAX](#authentication-ajax)\r\n  * [Secret Cookie](#secret-cookie)\r\n* [User Accounts](#user-accounts)\r\n  * [New User Collection](#new-user-collection)\r\n  * [Create Account Form](#create-account-form)\r\n  * [Create Account Script](#create-account-script)\r\n  * [After Create Account](#after-create-account)\r\n  * [Create Account Handler and URL Mapping](#create-account-handler-and-url-mapping)\r\n  * [Authenticate User with Password](#authenticate-user-with-password)\r\n* [Revisit List and User Authentication](#revisit-list-and-user-authentication)\r\n  * [Redefine List Collection](#redefine-list-collection)\r\n  * [Create Default List for New User](#create-default-list-for-new-user)\r\n  * [Authenticate User and Load List](#authenticate-user-and-load-list)\r\n  * [Revisit List Item Operations](#revisit-list-item-operations)\r\n* [Refactoring the App](#refactoring-the-app)\r\n  * [Base Handler](#base-handler)\r\n  * [Write Response](#write-response)\r\n  * [Error Handling](#error-handling)\r\n  * [Modular Templating](#modular-templating)\r\n  * [Common Javascript](#common-javascript)\r\n\r\n\r\n# Introduction\r\n\r\nThis is a prototype as part of learning Tornado framework. The idea and design of the app is based off [here](https://css-tricks.com/app-from-scratch-1-design/).\r\n\r\nI will attempt to write the README in tutorial style, as how I taught myself doing it from various sources.\r\n\r\nI will also try to commit the README and source code in accordance to the progress of the application.\r\n\r\nHopefully this will make it easier to follow the README and source code at different stages.\r\n\r\n*Please feel free to file issues regarding the README if you find something inaccurate or unclear about the explanation. This is my first time writing a public tutorial and I have a lot to learn from anyone of you who care enough to read this. Thank you so much for your support.*\r\n\r\n*Also, please do file issues regarding the actual source code if you find the code does not comply with certain standards or if improvements are needed. I am still new to python and there will surely be coding style which I have not followed.*\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Getting Started\r\n\r\n## Virtual Environment\r\n\r\nAs this is a python-based app, it is recommended to use `virtualenv` to contain the necessary packages for this project only.\r\n\r\nRun `pip install virtualenv` to install `virtualenv` if you don't already have the package.\r\n\r\nIn the directory you have created for this project, run the command `virtualenv venv` to create the directory for the new environment. Replace `venv` with any name you wish.\r\n\r\n*If you want to use python3 for the project, run `virtualenv -p python3 venv` instead. Make sure you already have python3 installed.*\r\n\r\nTo activate the environment, run the command `. venv/bin/activate` in the directory you have created `venv` directory.\r\n\r\nYou should see that your command prompt has `(venv)` in the prefix.\r\n\r\nYou can read more about `virtualenv` [here](https://virtualenv.readthedocs.org).\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Installing Packages\r\n\r\nThe packages required for getting started with developing this app is included in the `requirements.txt` file.\r\n\r\nRun `pip install -r requirements.txt` to install the packages.\r\n\r\nYou can read more about python package installation [here](https://pip.pypa.io/en/stable/user_guide/).\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Creating the App\r\n\r\n## The Main Application\r\n\r\nWe will start with a `app.py` file, which contains the basics of the application we want to create.\r\n\r\nFor now, we will not care about the application structure. Our goal here is just to get it to work.\r\n\r\nWe need to import some packages from the `tornado` framework.\r\n\r\n```\r\nimport tornado.ioloop\r\nimport tornado.web\r\nfrom tornado.web import url\r\n```\r\n\r\nWe will use a function to create the application instead of writing it directly in the main code.\r\n\r\n```\r\ndef make_app():\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n    ],\r\n    debug=True)\r\n```\r\n\r\nWe first define the main page URL and its handler. Whenever the client requests for `http://server:port/`, the `MainHandler` will handle the request and send the appropriate response.\r\n\r\nThe `debug=True` setting is to run the application in debug mode.\r\n\r\nNow we will define the `MainHandler`.\r\n\r\n```\r\nclass MainHandler(tornado.web.RequestHandler):\r\n    def get(self):\r\n        self.write('''<!DOCTYPE html>    \r\n                    <html>\r\n                    <head>\r\n                        <title>Colored List App</title>\r\n                    </head>\r\n                    <body>\r\n                        <div id=\"page-wrap\">\r\n                            <div id=\"header\">\r\n                                <h1><a href=\"/\">Colored List App</a></h1>\r\n                                <div id=\"control\">\r\n                                    <p><a href=\"/logout\" class=\"button\">Log Out</a>&nbsp;<a href=\"/account\" class=\"button\">Your Account</a></p>\r\n                                    <p><a href=\"/signup\" class=\"button\">Sign Up</a>&nbsp;<a href=\"/login\" class=\"button\">Log In</a></p>\r\n                                </div>\r\n                            </div>\r\n                            <div id=\"ribbon\">\r\n                                Reminders\r\n                                <ul>\r\n                                    <li>Your list automatically saves</li>\r\n                                    <li>Double-click list items to edit them</li>\r\n                                </ul>\r\n                            </div>\r\n                            <div id=\"main\">\r\n                            </div>\r\n                        </div>\r\n                    </body>\r\n                    </html>''')\r\n```\r\n\r\nWhen the client requests for `http://server:port/`, it will be sent as a `GET` request, so this will be handled by the `MainHandler`'s `get` function.\r\n\r\nWe will serve a HTML page as the response.\r\n\r\nNotice that I have injected some CSS classes and defined some IDs in the HTML elements. We will come to styling later.\r\n\r\nIn order for the server to run, we need to define the main entry code.\r\n\r\n```\r\nif __name__ == '__main__':\r\n    app = make_app()\r\n    app.listen(9080)\r\n    tornado.ioloop.IOLoop.current().start()\r\n```\r\n\r\nWe need to create an instance of the application by calling the `make_app()` function. Then I make it listen to port 9080. You can choose whichever port you wish.\r\n\r\nThe server is started by `tornado.ioloop.IOLoop.current().start()`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Templates\r\n\r\nIt is a little messy to write the HTML code directly in the `MainHandler`'s `get` function. We will try to take this code out into a proper HTML file, and get the handler to render the HTML file.\r\n\r\nWe first create the `main.html` file and put the exact HTML code into this file.\r\n\r\n```\r\n<!DOCTYPE html>    \r\n<html>\r\n<head>\r\n    <title>Colored List App</title>\r\n</head>\r\n<body>\r\n    <div id=\"page-wrap\">\r\n        <div id=\"header\">\r\n            <h1><a href=\"/\">Colored List App</a></h1>\r\n            <div id=\"control\">\r\n                <p><a href=\"/logout\" class=\"button\">Log Out</a>&nbsp;<a href=\"/account\" class=\"button\">Your Account</a></p>\r\n                <p><a href=\"/signup\" class=\"button\">Sign Up</a>&nbsp;<a href=\"/login\" class=\"button\">Log In</a></p>\r\n            </div>\r\n        </div>\r\n        <div id=\"ribbon\">\r\n            Reminders\r\n            <ul>\r\n                <li>Your list automatically saves</li>\r\n                <li>Double-click list items to edit them</li>\r\n            </ul>\r\n        </div>\r\n        <div id=\"main\">\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\nTo render this HTML file, we use the `render` method of the `RequestHandler` class.\r\n\r\nWe replace the `get` method we wrote earlier with the following:\r\n\r\n```\r\ndef get(self):\r\n    self.render(\"main.html\")\r\n```\r\n\r\nNow the code looks much cleaner as we separate the view out of the logic code.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Creating the List\r\n\r\nWe now have a basic structure application. It's time to start creating the list itself.\r\n\r\nWe will start with just 2 simple functionalities for the list.\r\n* View the list\r\n* Create a list item\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List URL Mapping\r\n\r\nFor each of the functionalities above, we will design endpoints for the client to send the requests to.\r\n\r\nIn the `make_app()` method we created earlier, we will add a few more `URLSpec` objects for each endpoint.\r\n\r\n```\r\ndef make_app():\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n        url(r\"/list/create\", ListHandler),\r\n        url(r\"/list\", ListHandler),\r\n    ],\r\n    debug=True)\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## In Memory Storage\r\n\r\nFor the time being, we will not use a persistent database for storage. Instead, we will create a in-memory storage for our list items.\r\n\r\nWe will come to using persistent storage at a later stage. For now, our purpose is to get the logic working.\r\n\r\nWe declare a global variable `list_items` that we will use as a in-memory storage for all the list items.\r\n\r\nWe will define it as a dictionary where the item ID will be the key and the item definition is another dictionary that forms the value paired with the key.\r\n\r\n```\r\nlist_items = {\r\n    '1':{'id':\"1\",'text':\"Walk the dog\",'color':\"Red\"},\r\n    '2':{'id':\"2\",'text':\"Pick up dry cleaning\",'color':\"Blue\"},\r\n    '3':{'id':\"3\",'text':\"Milk\",'color':\"Green\"},\r\n}\r\n```\r\n\r\nWe initialize some data first that we can display in the front-end.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Import UUID\r\n\r\nFor the purpose of using `uuid` to generate a unique ID for each item, we need to remember to import the `uuid` module.\r\n\r\n```\r\nimport uuid\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Template\r\n\r\nTo help us visualize the data, let's create the `list.html` template file first.\r\n\r\n```\r\n<ul>\r\n{% for item_id in items %}\r\n    <li class=\"{{ items[item_id]['color'] }}\">\r\n        <span>{{ items[item_id]['text'] }}</span>\r\n    </li>\r\n{% end %}\r\n</ul>\r\n\r\n<form action=\"/list/create\" method=\"post\">\r\n    <div>\r\n        <input type=\"text\" id=\"new-list-item-text\" name=\"text\">\r\n        <input type=\"submit\" id=\"new-item-submit\" value=\"Add\" class=\"button\">\r\n    </div>\r\n</form>\r\n```\r\n\r\nNotice something different is happening in this template. We have injected some python code in this template to help us display the list items.\r\n\r\nSince we are going to have a list of items, it is logical to have a loop control to display each item. This is where we use the `{% for item_id in items %}` construct.\r\n\r\nIn our in-memory store, we use the item ID as the key for the item definition itself, so in order to access the item data, we will need to get the item dictionary and then the attribute.\r\n\r\nFor example, we will use `{{ items[item_id]['text'] }}` to retrieve the text of the item with a specific `item_id`.\r\n\r\nWe have not added all the `<head>` and `<body>` tags in this template, because we are going to make use of template inheritance later.\r\n\r\nFor now we just want to make sure the data are displayed correctly with this structure.\r\n\r\nThis template should display a list of items in storage, and also provide a form to allow creating a new item which will be added to the in-memory storage.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Handler\r\n\r\nWe will not use the `MainHandler` for handling requests pertaining to the list. Instead, we will create a new `ListHandler` class for this purpose.\r\n\r\nFor each of the functionalities, we assign a method in the `ListHandler` according to the HTTP method we allow for access.\r\n\r\n```\r\nclass ListHandler(tornado.web.RequestHandler):\r\n    def get(self):\r\n        self.render(\"list.html\", items=list_items)\r\n\r\n    def post(self):\r\n        text = self.get_body_argument(\"text\")\r\n        item_id = str(uuid.uuid4())\r\n        list_items[item_id] = {'id':item_id,'text':text,'color':\"Blue\"}\r\n        self.redirect(\"/list\")\r\n```\r\nAs the client requests for `http://server:port/list`, the `ListHandler`'s `get` method will render the `list.html` page.\r\n\r\nIf the client enters some text in the form and hit the `Add` button, it will send a `POST` request containing the form data. The `ListHandler`'s `post` method will handle this request.\r\n\r\nFirst we will extract the text entered by the client by calling `self.get_body_argument(\"text\")`. Note that all form data are accessible by `self.get_body_argument` method by passing in the input name as the method parameter.\r\n\r\nWe will auto-generate a unique ID for this item by using `uuid.uuid4()` method.\r\n\r\nThen we create a new dictionary containing all the item data and add it to the in-memory `list_items` storage using the `item_id` as key.\r\n\r\nOnce we are done with the storage, we will redirect to the `/list` page so that the changes can be reflected to the user.\r\n\r\nWe will realize that the list items are not sorted according to the order they are created. For that, we will need to devise some data strucutre and logic to handle the sorting later.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Edit and Delete List Items\r\n\r\nA list without the edit or delete functions are almost useless. We will now add these functionalities to our list.\r\n\r\nThere can be a few ways to approach this problem.\r\n\r\n1. Continue using `ListHandler` and add the corresponding `put` and `delete` methods for editing and deleting list items.\r\n2. Create a separate `ListItemEditHandler` and `ListItemDeleteHandler` for editing and deleting list items.\r\n\r\nThe first approach will be more compact due to having only a single handler. The methods also clearly reflects the purpose of the request, mapping edit to `put` and delete to `delete` methods.\r\n\r\nHowever, we cannot simply use a form for editing and deleting, because HTML `<form>` does not support `put` and `delete` methods. We will need to use AJAX for these actions.\r\n\r\nThe second approach is more lengthy due to having to create 2 more handlers just for each of the actions.\r\n\r\nHowever, we can easily use a form to send a `post` request for each actions, and map to a `post` method within each handler.\r\n\r\nPersonally, I would prefer doing the first approach. I only need to main a single handler, while having the advantage of mapping the actions correctly to the methods: edit to `put` and delete to `delete`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Item URL Mapping\r\n\r\nFor using the first approach, we will map the request URL as follows:\r\n\r\n```\r\nurl(r\"/list/([0-9a-zA-Z\\-]+)/edit\", ListHandler),\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Item Handler\r\n\r\nSince it is an edit action, we will map it to the `put` method of the `ListHandler`.\r\n\r\n```\r\ndef put(self, item_id):\r\n    text = self.get_body_argument(\"text\")\r\n    item = None\r\n    try:\r\n        item = list_items[item_id]\r\n    except KeyError:\r\n        self.set_status(404)\r\n        self.finish(\"Not found\")\r\n        return\r\n    if item:\r\n        item['text'] = text\r\n    self.set_status(200)\r\n    self.finish(\"OK\")\r\n    return\r\n```\r\n\r\nThe `item_id` is already provided as a path argument. We only need to extract the `text` data from the request body by calling `self.get_body_argument` method.\r\n\r\nTo do a little error handling, we will try to get the item data from the `list_items` dictionary, while catching `KeyError`.\r\n\r\nIf `KeyError` is raised, then we will return a status of `404` and message `Not found` to inform the client of the error.\r\n\r\nIf the item is found, then we just overwrite the `text` value.\r\n\r\nAt the end of it, we will return a status of `200` and message `OK` to inform the client that the edit is done.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Importing Javascript\r\n\r\nWe can write plain Javascript for the AJAX calls, but I decide that it is best to use existing libraries to make our life easier.\r\n\r\nWe will use jQuery to help with handling the AJAX calls, so we will include this following code in the `list.html` file.\r\n\r\n```\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n```\r\n\r\nWe will add this `<script>` tag at the end of the page so that it does not slow down the page loading.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Edit Template\r\n\r\nThen, we will need to cater for editing by changing the `list.html` file. Previously we have a simple `<span>{{ items[item_id]['text'] }}</span>` to display the item text. Now we need to make it editable.\r\n\r\n```\r\n<span><input type=\"hidden\" id=\"edit-item-{{ item_id }}-id\" value=\"{{ item_id }}\"><input type=\"text\" id=\"edit-item-{{ item_id }}-text\" name=\"text\" value=\"{{ items[item_id]['text'] }}\"><a href=\"#\" id=\"edit-item-{{ item_id }}-submit\" class=\"button edit-button\">Edit</a></span>\r\n```\r\n\r\nWe have added a hidden field to store the `item_id`, put the item text in a text input field and created a link to submit the edit action.\r\n\r\nNote that we have created a unique ID for each input field as there may be multiple of such fields in the same list.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## AJAX\r\n\r\nNow we have the fields ready, we need to add in the logic to send the data to the server.\r\n\r\nBelow the `<script>` tag that imports the jQuery source, we will create our customized Javascript that will perform the AJAX call.\r\n \r\n```\r\n<script type=\"text/javascript\">\r\n<script type=\"text/javascript\">\r\n$(document).ready(function() {\r\n    $('.edit-button').click(function() {\r\n        var itemSpan = $(this).parent();\r\n        var itemId = $(itemSpan).find(\"input[type='hidden']\").val();\r\n        var text = $(itemSpan).find(\"input[name='text']\").val();\r\n        var url = \"/list/\" + itemId + \"/edit\";\r\n        console.log(url);\r\n        $.ajax({\r\n            type: \"PUT\",\r\n            url: url,\r\n            dataType: \"json\",\r\n            data: {\"id\": itemId, \"text\": text},\r\n            statusCode: {\r\n                200: function(xhr) {\r\n                    alert(\"Item updated successfully\");\r\n                },\r\n                404: function(xhr) {\r\n                    alert(\"Item ID not found\");\r\n                },\r\n            },\r\n        });\r\n    });\r\n});\r\n</script>\r\n```\r\n\r\nThere is quite a lot going on in this segment of code.\r\n\r\nFirst, we attach the `click` event to all the elements with the class `edit-button`. In this case, it will be all the `<a>` tags for each list item.\r\n\r\nOnce the `click` event is triggered, we will try to extract the data we require.\r\n\r\nWe get the parent `<span>` containing the `<a>` being clicked. This allows us to extract the element containing the `item_id` and `text` of the item.\r\n\r\nOnce we have these data, we can now construct the URL and data for the AJAX call.\r\n\r\nSince we have defined a `put` method in the `ListHandler` to handle the edit function, we will set the call type to `PUT`. The data will be sent as a `json` data type and the data itself is constructed using the values from the input fields.\r\n\r\nOnce the server returns a response, we will display an alert to inform the status.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Persistent Storage\r\n\r\nSo far we have been using a in-memory storage for our list items. For this application to be useful, we need to persist the list data so that users can re-visit the list another day and the data will still be available.\r\n\r\nNow we will look at how to integrate persistent storage in the application.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## pymongo\r\n\r\nThere are a few databases that we can use for our application. I have chosen [MongoDB](https://www.mongodb.org/) for the simple reason that I want to learn how to use a NoSQL database. Please visit the official docs to learn how to setup a MongoDB instance on your machine for testing purpose.\r\n\r\nIn order to use Tornado with MongoDB, we need to have a database driver called [pymongo](http://api.mongodb.org/python/current/index.html).\r\n\r\nWe will add `pymongo==3.2.2` to our `requirements.txt` file so that we can install the module using pip.\r\n\r\nAfter adding this line, don't forget to run the command `pip install -r requirements.txt` so that the pymongo package is installed.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Setting Up Database\r\n\r\nAfter installing MongoDB and pymongo, we need to setup the database for our application's use.\r\n\r\nWe create a new database called `coloredlistdb` and create a new collection `lists`.\r\n\r\nFirst, we run the `mongo` command to enter the MongoDB shell.\r\n\r\n```\r\n> mongo\r\nMongoDB shell version: 3.2.5\r\nconnecting to: test\r\nWelcome to the MongoDB shell.\r\nFor interactive help, type \"help\".\r\nFor more comprehensive documentation, see\r\n    http://docs.mongodb.org/\r\nQuestions? Try the support group\r\n    http://groups.google.com/group/mongodb-user\r\n```\r\n\r\nAt this point, there is no database created yet, so we run the following command to initialize a database for `coloredlistdb`.\r\n\r\n```\r\n> use coloredlistdb\r\nswitched to db coloredlistdb\r\n```\r\n\r\nWe will create a new collection to store our list items by running the following command.\r\n\r\n```\r\n> db.createCollection(\"lists\")\r\n{ \"ok\" : 1 }\r\n```\r\n\r\nWe also initialize some data in the collection so that our application will display some items on first run.\r\n\r\n```\r\n> db.lists.insert({\r\n... text:'Walk the dog',\r\n... color:'Red'\r\n... })\r\nWriteResult({ \"nInserted\" : 1 })\r\n> db.lists.insert({\r\n... text:'Pick up dry cleaning',\r\n... color:'Blue'\r\n... })\r\nWriteResult({ \"nInserted\" : 1 })\r\n> db.lists.insert({\r\n... text:'Milk',\r\n... color:'Green'\r\n... })\r\nWriteResult({ \"nInserted\" : 1 })\r\n```\r\n\r\nTo verify all the items have been inserted, we run the following command:\r\n\r\n```\r\n> db.lists.find()\r\n{ \"_id\" : ObjectId(\"57220c6dcbe425b0c391538e\"), \"text\" : \"Walk the dog\", \"color\" : \"Red\" }\r\n{ \"_id\" : ObjectId(\"57220ccfcbe425b0c391538f\"), \"text\" : \"Pick up dry cleaning\", \"color\" : \"Blue\" }\r\n{ \"_id\" : ObjectId(\"57220cdccbe425b0c3915390\"), \"text\" : \"Milk\", \"color\" : \"Green\" }\r\n```\r\n\r\nNotice that we have changed the data structure for list item. A MongoDB collection is analogous to a RDBMS table, each collection contains multiple documents, which is in turn analagous to RDBMS table rows. In MongoDB, each document is represented similar to JSON object.\r\n\r\nFor the purpose of our list items, we will define our data structure as follows:\r\n\r\n```\r\n{\r\n    \"_id\" : item_id,\r\n    \"text\" : item_text,\r\n    \"color\" : item_color\r\n}\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Make Database\r\n\r\nWe can now start using the database from the application itself.\r\n\r\nFirst of all, we need to import the required modules to use the pymongo driver.\r\n\r\n```\r\nfrom pymongo import MongoClient\r\nfrom bson.objectid import ObjectId\r\n```\r\n\r\nWe are going to use the `ObjectId` class for setting the item ID, so we can remove the `import uuid` statement.\r\n\r\nThen we create a method to initialize the database and return the database object.\r\n\r\n```\r\ndef create_db():\r\n    client = MongoClient(\"localhost\",27017)\r\n    db = client['coloredlistdb']\r\n    return db\r\n```\r\n\r\nIn this method, we create a `MongoClient` that connects to `localhost` port `27017`.\r\n\r\nThen we get the database of the name `coloredlistdb` as we have created earlier.\r\n\r\nWe will pass the database object to various request handlers for data storage and retrieval.\r\n\r\nSince we create our URLSpec in the `make_app` method, we will pass the database object to the method in the main code.\r\n\r\n```\r\nif __name__ == '__main__':\r\n    db = create_db()\r\n    app = make_app(db)\r\n```\r\n\r\nInside the `make_app` method, we will pass the database object to each URLSpec as follows:\r\n\r\n```\r\ndef make_app(db):\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/edit\", ListHandler, dict(db=db)),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/delete\", ListHandler, dict(db=db)),\r\n        url(r\"/list/create\", ListHandler, dict(db=db)),\r\n        url(r\"/list\", ListHandler, dict(db=db)),\r\n    ],\r\n    debug=True)\r\n```\r\n\r\nThen inside the `ListHandler` class, we need to add a `initialize` method to accept the database object and assign to its own `db` variable.\r\n\r\n```\r\ndef initialize(self, db):\r\n    self.db = db\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Using Database\r\n\r\nSince now that we have the database object in the `ListHandler`, we no longer use the in-memory storage.\r\n\r\nInstead, we will get the list by calling `self.db['lists']`.\r\n\r\nWe will need to update all `get`, `post`, `put` and `delete` methods to use this database object.\r\n\r\n```\r\ndef get(self):\r\n    list_items = self.db['lists']\r\n    items = [item for item in list_items.find()]\r\n    self.render(\"list.html\", items=items)\r\n\r\ndef post(self):\r\n    list_items = self.db['lists']\r\n    text = self.get_body_argument(\"text\")\r\n    list_items.insert_one({'text':text, 'color':'Blue'})\r\n    self.redirect(\"/list\")\r\n\r\ndef put(self, item_id):\r\n    list_items = self.db['lists']\r\n    text = self.get_body_argument(\"text\")\r\n    item = list_items.find_one({'_id':ObjectId(item_id)})\r\n    if item:\r\n        list_items.update_one({'_id':ObjectId(item_id)}, {'$set':{'text':text}})\r\n        self.set_status(200)\r\n        self.finish(\"OK\")\r\n        return\r\n    else:\r\n        self.set_status(404)\r\n        self.finish(\"Not found\")\r\n        return\r\n\r\ndef delete(self, item_id):\r\n    list_items = self.db['lists']\r\n    item = list_items.find_one({'_id':ObjectId(item_id)})\r\n    if item:\r\n        list_items.remove({'_id':ObjectId(item_id)})\r\n        self.set_status(200)\r\n        self.finish(\"OK\")\r\n        return\r\n    else:\r\n        self.set_status(404)\r\n        self.finish(\"Not found\")\r\n        return\r\n```\r\n\r\nLet's break it down a little and explain some of the new code.\r\n\r\nIn the `get` method, we get the collection object by calling `self.db['lists']`. To retrieve the documents, we need to get a cursor to the dataset by calling `list_items.find`, which is like a iterator to the documents. We use list comprehension construct `[item for item in list_items.find()]` to collect the documents into a list that can be used to render the `list.html` page.\r\n\r\nFor the `post` method, we will call the `list_items.insert_one` method, passing in the dictionary containing the item text and color as parameter. The `_id` field will be automatically generated.\r\n\r\nFor the `put` method, we will first call `list_items.find_one` and pass in the `ObjectId(item_id)` as the query filter. This will return us only one result or none. If the result is not none, then we will update the collection and setting a new `text` value for the document with `_id` `ObjectId(item_id)`.\r\n\r\nFinally in the `delete` method, similar to the `put` method, we first query the collection to get the document with the same `ObjectId(item_id)`, then we simply call `list_items.remove` to delete the document from the collection.\r\n\r\nNotice that we cannot simply pass the plain `item_id` string as the `_id` value, instead, we need to create a new `ObjectId` object with the `item_id`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Template with New Data Structure\r\n\r\nSince we have changed the data structure of the list item, we also need to update the list view to reflect the changes.\r\n\r\n```\r\n{% for item in items %}\r\n    <li class=\"{{ item['color'] }}\">\r\n        <span><input type=\"hidden\" id=\"edit-item-{{ item['_id'] }}-id\" value=\"{{ item['_id'] }}\"><input type=\"text\" id=\"edit-item-{{ item['_id'] }}-text\" name=\"text\" value=\"{{ item['text'] }}\"><a href=\"#\" id=\"edit-item-{{ item['_id'] }}-submit\" class=\"button edit-button\">Edit</a><a href=\"#\" id=\"delete-item-{{ item['_id'] }}-submit\" class=\"button delete-button\">Delete</a></span>\r\n    </li>\r\n{% end %}\r\n```\r\n\r\nInstead of iterating through the IDs as in the earlier version, we now can iterate through the list of items directly.\r\n\r\nTo access the `text` and `value` attributes, we just call `item['text']` or `item['color']`.\r\n\r\nPreviously, we have not included the `Delete` function. Now we will add the AJAX call for deleting the item. It is similar in structure to the edit AJAX call, except that here we are using type `DELETE` and there is no need to send any data in the request.\r\n\r\n```\r\n$('.delete-button').click(function() {\r\n    var itemSpan = $(this).parent();\r\n    var itemId = $(itemSpan).find(\"input[type='hidden']\").val();\r\n    var text = $(itemSpan).find(\"input[name='text']\").val();\r\n    var url = \"/list/\" + itemId + \"/delete\";\r\n    console.log(url);\r\n    $.ajax({\r\n        type: \"DELETE\",\r\n        url: url,\r\n        dataType: \"json\",\r\n        data: {},\r\n        statusCode: {\r\n            200: function(xhr) {\r\n                alert(\"Item deleted successfully\");\r\n                window.location.href = \"/list\";\r\n            },\r\n            404: function(xhr) {\r\n                alert(\"Item ID not found\");\r\n            },\r\n        },\r\n    });\r\n});\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Structuring the App\r\n\r\nNow we have a functional app where we can list items, add new item, edit and remove existing item.\r\n\r\nHowever, the current structure is not the most ideal one. We have embedded Javascript directly in the `list.html` file, which makes it more difficult to maintain, and we cannot make use of caching to make our page load faster.\r\n\r\nIdeally, we want to separate HTML, Javascript and CSS scripts into separate files, so that the browsers can cache unchanged `.js` and `.css` files, making page loading faster.\r\n\r\nIn the following sections, we will go through how to separate our Javascripts from the HTML pages.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Static Content\r\n\r\nIt is a common practice to create a `static` directory, containing `js`, `css` and `img` sub-directories. Each of these directories will contain Javascript, CSS and image files.\r\n\r\nThen inside our HTML page, we will include them by using tags like `<script src=\"\"></script>` for Javascript and `<link href=\"\">` for CSS.\r\n\r\nFor our app, we will create `static` in the same directory as `app.py`, and contain `js`, `css` and `img` sub-directories like this:\r\n\r\n```\r\n+-- coloredlist/\r\n|   +-- app.py\r\n|   +-- static/\r\n|   |   +-- css/\r\n|   |   +-- img/\r\n|   |   +-- js/\r\n```\r\n\r\nThen, we will create a new file `list.js` under the `static/js` directory, and extract the Javascript from `list.html` into this new file.\r\n\r\n### `list.js`\r\n\r\n```\r\n$(document).ready(function() {\r\n    $('.edit-button').click(function() {\r\n        var itemSpan = $(this).parent();\r\n        var itemId = $(itemSpan).find(\"input[type='hidden']\").val();\r\n        var text = $(itemSpan).find(\"input[name='text']\").val();\r\n        var url = \"/list/\" + itemId + \"/edit\";\r\n        console.log(url);\r\n        $.ajax({\r\n            type: \"PUT\",\r\n            url: url,\r\n            dataType: \"json\",\r\n            data: {\"id\": itemId, \"text\": text},\r\n            statusCode: {\r\n                200: function(xhr) {\r\n                    alert(\"Item updated successfully\");\r\n                },\r\n                404: function(xhr) {\r\n                    alert(\"Item ID not found\");\r\n                },\r\n            },\r\n        });\r\n    });\r\n    $('.delete-button').click(function() {\r\n        var itemSpan = $(this).parent();\r\n        var itemId = $(itemSpan).find(\"input[type='hidden']\").val();\r\n        var text = $(itemSpan).find(\"input[name='text']\").val();\r\n        var url = \"/list/\" + itemId + \"/delete\";\r\n        console.log(url);\r\n        $.ajax({\r\n            type: \"DELETE\",\r\n            url: url,\r\n            dataType: \"json\",\r\n            data: {},\r\n            statusCode: {\r\n                200: function(xhr) {\r\n                    alert(\"Item deleted successfully\");\r\n                    window.location.href = \"/list\";\r\n                },\r\n                404: function(xhr) {\r\n                    alert(\"Item ID not found\");\r\n                },\r\n            },\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n### `list.html`\r\n\r\n```\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n<script src=\"{{ static_url('js/list.js') }}\"></script>\r\n```\r\n\r\nNotice that we are using `static_url()` for the `list.js` URL formation, which will return the `list.js` relative to the static file path defined in our application as follows:\r\n\r\n```\r\ndef make_app(db):\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/edit\", ListHandler, dict(db=db)),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/delete\", ListHandler, dict(db=db)),\r\n        url(r\"/list/create\", ListHandler, dict(db=db)),\r\n        url(r\"/list\", ListHandler, dict(db=db)),\r\n    ],\r\n    debug=True,\r\n    static_path=os.path.join(os.path.dirname(__file__), \"static\"))\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Template Inheritance\r\n\r\nPreviously we made a note about template inheritance when we were making the list page. Now we have finally come to this part where we are going to make some base templates that can be extended by various pages.\r\n\r\nFirst of all, we need to create a new directory `templates` in the same directory as `app.py`. Then we need to inform our application to load templates from the `templates` directory through the `template_path` setting:\r\n\r\n```\r\ndef make_app(db):\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/edit\", ListHandler, dict(db=db)),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/delete\", ListHandler, dict(db=db)),\r\n        url(r\"/list/create\", ListHandler, dict(db=db)),\r\n        url(r\"/list\", ListHandler, dict(db=db)),\r\n    ],\r\n    debug=True,\r\n    static_path=os.path.join(os.path.dirname(__file__), \"static\"),\r\n    template_path=os.path.join(os.path.dirname(__file__), \"templates\"))\r\n```\r\n\r\nWe now create a new file called `base.html`. Basically what this file will contain is the entire HTML markup of `main.html` with some additions, and it will be the base of all our pages.\r\n\r\n```\r\n<!DOCTYPE html>    \r\n<html>\r\n<head>\r\n    <title>Colored List App</title>\r\n</head>\r\n<body>\r\n    <div id=\"page-wrap\">\r\n        <div id=\"header\">\r\n            <h1><a href=\"/\">Colored List App</a></h1>\r\n            <div id=\"control\">\r\n                <p><a href=\"/logout\" class=\"button\">Log Out</a>&nbsp;<a href=\"/account\" class=\"button\">Your Account</a></p>\r\n                <p><a href=\"/signup\" class=\"button\">Sign Up</a>&nbsp;<a href=\"/login\" class=\"button\">Log In</a></p>\r\n            </div>\r\n        </div>\r\n        <div id=\"ribbon\">\r\n            Reminders\r\n            <ul>\r\n                <li>Your list automatically saves</li>\r\n                <li>Double-click list items to edit them</li>\r\n            </ul>\r\n        </div>\r\n        <div id=\"main\">\r\n        {% block content %}\r\n        {% end %}\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\nUnder `<div id=\"main\">`, we add the Python expressions:\r\n\r\n```\r\n{% block content %}\r\n{% end %}\r\n```\r\n\r\nThis allow us to extend the `base.html` template and put various page contents within this `div`.\r\n\r\nWe also need to move our `main.html` and `list.html` into the newly created `templates` directory.\r\n\r\nNow we can extend `base.html` in `list.html` like this:\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<ul>\r\n{% for item in items %}\r\n    <li class=\"{{ item['color'] }}\">\r\n        <span><input type=\"hidden\" id=\"edit-item-{{ item['_id'] }}-id\" value=\"{{ item['_id'] }}\"><input type=\"text\" id=\"edit-item-{{ item['_id'] }}-text\" name=\"text\" value=\"{{ item['text'] }}\"><a href=\"#\" id=\"edit-item-{{ item['_id'] }}-submit\" class=\"button edit-button\">Edit</a><a href=\"#\" id=\"delete-item-{{ item['_id'] }}-submit\" class=\"button delete-button\">Delete</a></span>\r\n    </li>\r\n{% end %}\r\n</ul>\r\n\r\n<form action=\"/list/create\" method=\"post\">\r\n    <div>\r\n        <input type=\"text\" id=\"new-list-item-text\" name=\"text\">\r\n        <input type=\"submit\" id=\"new-item-submit\" value=\"Add\" class=\"button\">\r\n    </div>\r\n</form>\r\n\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n<script src=\"{{ static_url('js/list.js') }}\"></script>\r\n{% end %}\r\n```\r\n\r\nFirst, we need to indicate that we are extending from `base.html` by the expression `{% extends \"base.html\" %}`.\r\n\r\nThen we indicate that we will extend the `{% block content %}` block by including our original `list.html` markup under `{% block content %}{% end %}` block.\r\n\r\nWhen we load our `/list` page, we will have all the markup from `base.html` including `<div class=\"header\">` and `<div class=\"ribbon\">`, followed by the `{% block content %}` block, which will include `<ul>` and `<form>`.\r\n\r\nFor `main.html`, since we have just basically migrated the entire markup into `base.html`, we can just extend `base.html` directly inside `main.html` like this:\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n```\r\n\r\nThe advantage of template inheritance is that we don't need to copy-paste the header and footer everytime we create a new page with the same look-and-feel.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Handlers Module\r\n\r\nThe next thing we want to tackle here is `app.py`. Notice that it has grown in size pretty quickly even though have just started with 2 handlers. We want to make it easily maintainable, so we should start separating different handlers into their rightful places.\r\n\r\nFirst, we need to create a new directory `handlers` in the same directory as `app.py`. Then we create `__init__.py` in `handlers` to indicate that it should be a `import`-able module.\r\n\r\nWe will migrate `class MainHandler` and `class ListHandler` into separate files, `main.py` and `list.py` respectively inside `handlers` directory.\r\n\r\nWhat we have will be like this:\r\n\r\n### `main.py`\r\n\r\n```\r\nimport tornado.web\r\n\r\n\r\nclass MainHandler(tornado.web.RequestHandler):\r\n    def get(self):\r\n        self.render(\"main.html\")\r\n```\r\n\r\n### `list.py`\r\n\r\n```\r\nimport tornado.web\r\nfrom bson.objectid import ObjectId\r\n\r\n\r\nclass ListHandler(tornado.web.RequestHandler):\r\n    def initialize(self, db):\r\n        self.db = db\r\n\r\n    def get(self):\r\n        # ommitted for simplicity\r\n\r\n    def post(self):\r\n        # ommitted for simplicity\r\n\r\n    def put(self, item_id):\r\n        # ommitted for simplicity\r\n\r\n    def delete(self, item_id):\r\n        # ommitted for simplicity\r\n```\r\n\r\nSince we have extracted these 2 classes out of `app.py`, we need to tell the main application where to get the 2 handlers. For that, we need to import the 2 handlers from the newly created `handlers` module like this:\r\n\r\n```\r\nfrom handlers.main import MainHandler\r\nfrom handlers.list import ListHandler\r\n```\r\n\r\nWe don't need to change anything about the URLSpec definitions in creating the `tornado.web.Application` object.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## App Settings\r\n\r\nOur app is starting to look more structured than when we first started building it. We want to take a step further and make it more easily configurable by extracting all settings into a separate file called `settings.py`, which we will craete under the same directory as `app.py`.\r\n\r\n```\r\nimport os\r\nfrom tornado.options import define, options\r\n\r\n\r\n# Define file paths\r\nROOT = os.path.join(os.path.dirname(__file__))\r\nSTATIC_ROOT = os.path.join(ROOT, \"static\")\r\nTEMPLATE_ROOT = os.path.join(ROOT, \"templates\")\r\n\r\n\r\n# Define global options\r\ndefine(\"port\", default=9080, help=\"server port\", type=int)\r\ndefine(\"debug\", default=True, help=\"debug mode\")\r\ndefine(\"dbhost\", default=\"localhost\", help=\"db host\")\r\ndefine(\"dbport\", default=27017, help=\"db port\", type=int)\r\ndefine(\"dbname\", default=\"coloredlistdb\", help=\"name of db\")\r\n\r\n\r\n# Define application settings\r\nsettings = {}\r\nsettings['debug'] = options.debug\r\nsettings['static_path'] = STATIC_ROOT\r\nsettings['template_path'] = TEMPLATE_ROOT\r\n```\r\n\r\nIn the newly created `settings.py` file, we will define the `STATIC_ROOT` and `TEMPLATE_ROOT` variables to be used in the application settings for `static_path` and `template_path` respectively.\r\n\r\nWe also make use of `tornado.options.options`, which is a global options object, to store certain options like `port` and `dbhost` etc by calling the `define` function.\r\n\r\nSince we have extracted all the settings and options into a separate file, we need to tell our application how to load these settings and options. In our `app.py` file, we will need to import the `settings` object and `tornado.options.options` object:\r\n\r\n```\r\nfrom settings import settings\r\nfrom tornado.options import options\r\n```\r\n\r\nThen we can make use of the settings and options like this:\r\n\r\n```\r\ndef create_db():\r\n    client = MongoClient(options.dbhost, options.dbport)\r\n    db = client[options.dbname]\r\n    return db\r\n\r\ndef make_app(db):\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/edit\", ListHandler, dict(db=db)),\r\n        url(r\"/list/([0-9a-zA-Z\\-]+)/delete\", ListHandler, dict(db=db)),\r\n        url(r\"/list/create\", ListHandler, dict(db=db)),\r\n        url(r\"/list\", ListHandler, dict(db=db)),\r\n    ],\r\n    **settings)\r\n\r\nif __name__ == '__main__':\r\n    db = create_db()\r\n    app = make_app(db)\r\n    app.listen(options.port)\r\n    tornado.ioloop.IOLoop.current().start()\r\n```\r\n\r\nBy separating the settings and options from our application, we can make changes to the settings and options without having to change the `app.py` directly. It gives us the flexibility to deploy the application on different servers and using different databases by just dealing with `settings.py` file.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## DB Settings\r\n\r\nSince I've mentioned about using different databases for our app, we might as well make our app database-independent, meaning we shouldn't be tied to using only MongoDB, but have the option to use MySQL or PostgreSQL or whichever database deemed appropriate. For this, we have to restructure how we define our `db` object. Instead of creating the `db` object inside `app.py`, we will create a separate `db.py` under the same directory as `app.py`, where we will create a `db` object for our application's use.\r\n\r\n```\r\nfrom pymongo import MongoClient\r\nfrom tornado.options import options\r\n\r\n\r\ndef create_db():\r\n    client = MongoClient(options.dbhost, options.dbport)\r\n    db = client[options.dbname]\r\n    return db\r\n    \r\ndb = create_db()\r\n```\r\n\r\nThen, we will remove the `create_db` function from `app.py`, and instead do a import of the `db` object:\r\n\r\n```\r\nfrom db import db\r\n```\r\n\r\nWe can also remove the call to `create_db` in our main code:\r\n\r\n```\r\nif __name__ == '__main__':\r\n    app = make_app()\r\n    app.listen(options.port)\r\n    tornado.ioloop.IOLoop.current().start()\r\n```\r\n\r\nWe are not yet ready to be database-independent, but we will come to creating a database wrapper in a while.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## URL Patterns\r\n\r\nHonestly, I still haven't figured out why it is best practice to put URLs into a separate file. I guess it is probably for maintainability reasons. Personally I would also prefer defining the URLs separately from the main application, so that the `app.py` file will look clean and lean.\r\n\r\nWe will create a new `urls.py` file under the same directory as `app.py`. It will just contain our URLSpecs as follows:\r\n\r\n```\r\nfrom tornado.web import url\r\nfrom handlers.main import MainHandler\r\nfrom handlers.list import ListHandler\r\nfrom db import db\r\n\r\n\r\nurl_patterns = [\r\n    url(r\"/\", MainHandler),\r\n    url(r\"/list/([0-9a-zA-Z\\-]+)/edit\", ListHandler, dict(db=db)),\r\n    url(r\"/list/([0-9a-zA-Z\\-]+)/delete\", ListHandler, dict(db=db)),\r\n    url(r\"/list/create\", ListHandler, dict(db=db)),\r\n    url(r\"/list\", ListHandler, dict(db=db)),\r\n]\r\n```\r\n\r\nSince we have extracted the URLs from `app.py`, we no longer need to import `db` and `handlers` in `app.py`, and the file should look like this now:\r\n\r\n```\r\nimport tornado.ioloop\r\nimport tornado.web\r\nfrom settings import settings\r\nfrom tornado.options import options\r\nfrom urls import url_patterns\r\n\r\n\r\ndef make_app():\r\n    return tornado.web.Application(url_patterns, **settings)\r\n\r\n\r\nif __name__ == '__main__':\r\n    app = make_app()\r\n    app.listen(options.port)\r\n    tornado.ioloop.IOLoop.current().start()\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Final Structure\r\n\r\nAt the end of all the restructuring, we should have achieved our desired structure for the application:\r\n\r\n```\r\n+-- coloredlist/\r\n|   +-- app.py\r\n|   +-- db.py\r\n|   +-- settings.py\r\n|   +-- urls.py\r\n|   +-- handlers/\r\n|   |   +-- __init__.py\r\n|   |   +-- list.py\r\n|   |   +-- main.py\r\n|   +-- static/\r\n|   |   +-- css/\r\n|   |   +-- img/\r\n|   |   +-- js/\r\n|   |   |   +-- list.js\r\n|   +-- templates/\r\n|   |   +-- base.html\r\n|   |   +-- list.html\r\n|   |   +-- main.html\r\n```\r\n\r\nThis may not be the best structure for a Tornado app, but we will improve on it as we add in more advanced features.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Styling the App\r\n\r\nSince this is mainly a Tornado tutorial, I'm not going to focus much on styling the app. My purpose here is just to learn how to incorporate CSS files into my templates, so I'm going to take almost every CSS defined from the [sample](https://css-tricks.com/app-from-scratch-4-html-css/) and tweak such that there is no loading errors.\r\n\r\nThe end product is not going to look very nice, but that's really not our main concern here.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Basic CSS\r\n\r\nRemember we have created our `static/css` folder earlier? Now we can put it into some use. Inside the directory, we will create 3 files, `main.css`, `list.css` and `sidebar.css`.\r\n\r\n### `main.css`\r\n\r\nDue to the file being quite loaded, I'm going to just extract a few lines here. For the complete CSS file, please refer to the source code.\r\n\r\n```\r\n* { margin: 0; padding: 0; }\r\nbody { font: 14px/1.1 Helvetica, Sans-Serif; }\r\n.clear { clear: both; }\r\nimg, a img { border: none; }\r\ninput { outline: none; }\r\n```\r\n\r\n### `list.css`\r\n\r\n```\r\n#list { list-style: none; }\r\n#list li { position: relative; margin: 0 0 8px 0; padding: 0 0 0 70px; width: 607px; }\r\n#list li span { padding: 2px; -moz-border-radius: 5px; -webkit-border-radius: 5px; width: 589px; display: block; position: relative; }\r\n```\r\n\r\n### `sidebar.css`\r\n\r\n```\r\n#ribbon { position: absolute; right: 0; width: 125px; padding: 60px 30px 0 47px; height: 756px; top: -6px; }\r\n\r\n#ribbon ul { list-style: none; }\r\n#ribbon ul li { background: rgba(0,0,0,0.8); color: white; padding: 5px; margin: 0 0 5px 0; font-size: 12px; }\r\n```\r\n\r\nThen, we need to import the CSS files within the HTML templates like this:\r\n\r\n### `base.html`\r\n\r\n```\r\n<head>\r\n    <title>Colored List App</title>\r\n    <link rel=\"stylesheet\" href=\"{{ static_url('css/main.css') }}\">\r\n    <link rel=\"stylesheet\" href=\"{{ static_url('css/sidebar.css') }}\">\r\n</head>\r\n```\r\n\r\n### `list.html`\r\n\r\n```\r\n{% block content %}\r\n<link rel=\"stylesheet\" href=\"{{ static_url('css/list.css') }}\">\r\n<ul id=\"list\">\r\n...\r\n</ul>\r\n<form id=\"add-new\" action=\"/list/create\" method=\"post\">\r\n    <div>\r\n        <input type=\"text\" id=\"new-list-item-text\" name=\"text\">\r\n        <input type=\"submit\" id=\"new-item-submit\" value=\"Add\" class=\"button\">\r\n    </div>\r\n</form>\r\n{% end %}\r\n```\r\n\r\nNote that for `list.html`, we have added an `id` attribute for the list `ul` element and `form` element. This is so that we can style them using our newly created stylesheets.\r\n\r\nNow our app should have basic styling, although it most likely isn't very pleasant.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# User Authentication\r\n\r\nNotice that all this while we have been freely accessing our list without having to login at all. In this age where security is a concern, no one would use our app if it does not have any form of authentication. Now, we will start building in user authentication feature for our app.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Login Form\r\n\r\nFirst of all, we will define our login form. It will be a simple form, with username and password fields.\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<form action=\"/login/submit\" method=\"post\">\r\n    <div>\r\n        <input type=\"text\" name=\"username\" id=\"username\">\r\n        <label for=\"username\">Username</label>\r\n        <input type=\"password\" name=\"password\" id=\"password\">\r\n        <label for=\"password\">Password</label>\r\n    </div>\r\n    <input type=\"submit\" id=\"login-submit\" value=\"Login\" class=\"button\">\r\n</form>\r\n{% end %}\r\n```\r\n\r\nWe will extend our `base.html` template and define the login form within `{% block content %}`.\r\n\r\nThere is nothing special about this form. We specify the action `/login/submit`, and will send the request as a `POST` request.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Login and Logout Handlers\r\n\r\nWe need to create handlers for our login form. We will create a new file `auth.py` under `handlers` directory, and create `class LoginHandler` inside the handler.\r\n\r\nWe will have a `get` function to handle `GET` request and `post` function to handle `POST` request. The `get` function will simply return our `login.html` form. When the login form sends a `POST` request, the `post` function will take the `username` from the request argument by calling `self.get_argument(\"username\")`. We will set this username in our session cookie with `user` key, then redirect to the `/list` URL to display the list view.\r\n\r\nFor the time being, we will omit password authentication as this will require searching through the persistent datastore.\r\n\r\n```\r\nimport tornado.web\r\nimport json\r\n\r\n\r\nclass LoginHandler(tornado.web.RequestHandler):\r\n    def initialize(self, db):\r\n        self.db = db\r\n\r\n    def get(self):\r\n        self.render(\"login.html\")\r\n\r\n    def post(self):\r\n        self.set_secure_cookie(\"user\", self.get_argument(\"username\"))\r\n        self.redirect(\"/list\")\r\n```\r\n\r\nFor every authentication feature, there will be a logout function as well. We will then define another `class LogoutHandler` under `auth.py`.\r\n\r\n```\r\nclass LogoutHandler(tornado.web.RequestHandler):\r\n    def initialize(self, db):\r\n        self.db = db\r\n\r\n    def post(self):\r\n        response = {}\r\n        if self.get_secure_cookie(\"user\"):\r\n            self.set_secure_cookie(\"user\", \"\")\r\n            response['status'] = 200\r\n            response['redirectUrl'] = \"/login\"\r\n            self.write(json.dumps(response))\r\n        else:\r\n            response['status'] = 400\r\n            response['errorMsg'] = \"User not in session\"\r\n            response['redirectUrl'] = \"/login\"\r\n            self.write(json.dumps(response))\r\n```\r\n\r\nBasically, we will remove the user from our session cookie by setting the `user` key value to empty. Then we will create a response dictionary with `status=200` and `redirectUrl=/login`. However, if with any reason the user is no longer in session, we will return `status=400` with `errorMsg=User not in session` and `redirectUrl=/login`.\r\n\r\nSince we now have an authentication feature, we must not forget to make sure our list page is *protected* against unauthenticated access. To do that, we have to modify our `MainHandler`'s `get` function as such:\r\n\r\n```\r\nclass MainHandler(tornado.web.RequestHandler):\r\n    def get(self):\r\n        if not self.get_secure_cookie(\"user\"):\r\n            self.redirect(\"/login\")\r\n            return\r\n        self.redirect(\"/list\")\r\n```\r\n\r\nWhat this does is that it will first check whether there is any user in the session cookie, and redirect to `/login` if there is no user, or to `/list` if user is still in session. Of course this is not very secure, we should check whether the request comes from the same user in session, but we will leave that to a later stage.\r\n\r\nThis is all very messy code and we shall come back later to refactor it. By then, we will need to introduce the concept of a `BaseHandler`. Let's come to that at a later stage.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Authentication URL Patterns\r\n\r\nOnce we have created our `LoginHandler` and `LogoutHandler`, we can map the handlers to the respect URLs.\r\n\r\nInside our `urls.py` file, we will add a new `import` statement:\r\n\r\n```\r\nfrom handlers.auth import LoginHandler, LogoutHandler\r\n```\r\n\r\nThen, we will add the mapping as such:\r\n\r\n```\r\nurl(r\"/login\", LoginHandler, dict(db=db)),\r\nurl(r\"/login/submit\", LoginHandler, dict(db=db)),\r\nurl(r\"/logout\", LogoutHandler, dict(db=db)),\r\n```\r\n\r\nThis is very straightforward by now. We will let `LoginHandler` handle `/login` and `/login/submit` URLs and `LogoutHandler` handle `/logout` URL.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Authentication AJAX\r\n\r\nRemember we created a `Logout` button very early in our app development? We shall now put it into use.\r\n\r\nIn our `base.html`, we need to make a little change to our `Logout` button. Instead of calling `/logout` directly in the `a href` attribute, we need to use AJAX for the call, because `a href` only sends `GET` request.\r\n\r\n```\r\n<p><a href=\"#\" id=\"logout-btn\" class=\"button\">Log Out</a>&nbsp;<a href=\"/account\" class=\"button\">Your Account</a></p>\r\n```\r\n\r\nTo perform AJAX call, we will include the jQuery library and our `main.js` scripts at the bottom of `base.html`, before the closing `body` tag.\r\n\r\n```\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n<script src=\"{{ static_url('js/main.js') }}\"></script>\r\n```\r\n\r\nThen inside `static/js` directory, we will create a new file for `main.js` and write our AJAX call.\r\n\r\n```\r\n$(document).ready(function() {\r\n    $('#logout-btn').click(function() {\r\n        $.ajax({\r\n            type: \"POST\",\r\n            url: \"/logout\",\r\n            success: function(response) {\r\n                if (response) {\r\n                    response = JSON.parse(response);\r\n                    if (response.status == 200) {\r\n                        alert(response.errorMsg || \"Logged out successfully.\");\r\n                    } else {\r\n                        alert(response.errorMsg || \"Error logging out\");\r\n                    }\r\n                    window.location.href = response.redirectUrl;\r\n                }\r\n            }\r\n        });\r\n    }); \r\n});\r\n```\r\n\r\nWe will attach a AJAX call to the `click` event of our `logout-btn`. This should send a `POST` request to the `/logout` URL.\r\n\r\nOn success, we will check for the response, we will parse into a JSON object for processing.\r\n\r\nIf the `response.status` is `200`, we will prompt the `response.errorMsg` or `Logged out successfully`. Otherwise, we will prompt the `response.errorMsg` or `Error logging out`.\r\n\r\nIn both cases, we will redirect the browser to the `response.redirectUrl` given by the server.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Secret Cookie\r\n\r\nAt the end of all this, there is one very important thing that we need to do for this authentication feature to work. We have to define a secret cookie key in our application, which is used to sign our cookies to prevent forgery.\r\n\r\nThis part is a bit tricky. The secret cookie key is supposed to be set in our `settings.py` file, but our application is open source, and everyone can see the `settings.py` source code. This means everyone will see our secret cookie key, and can as easily forge a cookie.\r\n\r\nTo solve this problem, we will have to define one configuration file to store the secret cookie key, and this file should never be made public and will only live in our server. Let's call the file `config.conf`. This file will store our secret cookie key in the form of `cookie_secret = 'some long string of characters'`.\r\n\r\nThen our `settings.py` file will be modified to include reading the `config.conf` file and setting the `cookie_secret`:\r\n\r\n```\r\nimport tornado\r\nfrom tornado.options import define, options, parse_config_file \r\n```\r\n\r\nFirst we will make additional imports for `parse_config_file`.\r\n\r\n```\r\ndefine(\"cookie_secret\", default=None, help=\"secret cookie\")\r\ndefine(\"config\", default=\"config.conf\", help=\"secret config\")\r\n```\r\n\r\nThen we will define the `cookie_secret` and `config` options. We will not be setting the `cookie_secret` directly here, instead we will make use of `config.conf` to read the value.\r\n\r\n```\r\nif options.config:\r\n    if os.path.exists(options.config):\r\n        parse_config_file(options.config)\r\n```\r\n\r\nTo read the `config.conf` file, we will call the `parse_config_file` function, passing in the file name, which is defined in `options.config`.\r\n\r\n```\r\nsettings['cookie_secret'] = options.cookie_secret\r\n```\r\n\r\nFinally, once we have read the option from `config.conf`, we can set it to our `settings['cookie_secret']`, which will be passed to the `Application` object during creation.\r\n\r\nNow, our application is ready for authentication.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# User Accounts\r\n\r\nBased on our user authentication feature earlier, it doesn't really authenticate anyone, as it just stores the username in session without checking against the database whether the password is matching. We shall now create the concept of user accounts, so that we will have a database of users to authenticate against for every login.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## New User Collection\r\n\r\nTo store user accounts in our database, we need to create a new collection called `users`. Let's start up our MongoDB client to create the collection.\r\n\r\n```\r\n> mongo\r\nMongoDB shell version: 3.2.6\r\nconnecting to: test\r\n> use coloredlistdb\r\nswitched to db coloredlistdb\r\n>\r\n```\r\n\r\nWe will call up the MongoDB shell using the `mongo` command. Then we switch to our database by `use coloredlistdb`.\r\n\r\n```\r\n> db.createCollection(\"users\")\r\n{ \"ok\" : 1 }\r\n>\r\n```\r\n\r\nWe will create a new collection to store our user accounts by running `db.createCollection(\"users\")`.\r\n\r\nNow we want create our first user account, let's make it the `admin` user. We are going to hash the password for this user, so we will need the help of the Python console. Let's call up `python`.\r\n\r\n```\r\n> python\r\nPython 3.5.1+ (default, Mar 30 2016, 22:46:26)\r\n[GCC 5.3.1 20160330] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import hashlib, pymongo\r\n>>> hashed_pass = hashlib.md5(\"admin\".encode(\"utf-8\")).hexdigest()\r\n>>> hashed_pass\r\n'21232f297a57a5a743894a0e4a801fc3'\r\n>>> client = pymongo.MongoClient(\"localhost\", 27017)\r\n>>> db = client.coloredlistdb\r\n>>> users = db.users\r\n>>> users.insert_one({'username': \"admin\", 'password': hashed_pass, 'is_active': True, 'is_admin': True})\r\n<pymongo.results.InsertOneResult object at 0x7fe0779c7dc8>\r\n>>>\r\n```\r\n\r\nIn the Python console, we `import hashlib` which deals with hashing. Then we pass in our password `password` into the `hashlib.md5` function, but before that, we need to encode our `password` string with `encode(\"utf-8\")`. Once the hash object is created, we call `hexdigest` to get the digest in hexadecimals digits. This is the string that we will use to store in the `users` collection.\r\n\r\nSince we are using the Python console to generate the hashed password, we might as well use it to insert the user into our database. We create a `MongoClient` and get the `users` collection from the `coloredlistdb`. Then we insert the `admin` user with the following details:\r\n\r\n```\r\n{'username': \"admin\", 'password': hashed_pass, 'is_active': True, 'is_admin': True}\r\n```\r\n\r\nAfter this, if we query the database from the MongoDB shell, we should find the document created.\r\n\r\n```\r\n> db.users.find()\r\n{ \"_id\" : ObjectId(\"572cbfceaeca133de672b178\"), \"is_admin\" : true, \"is_active\" : true, \"password\" : \"21232f297a57a5a743894a0e4a801fc3\", \"username\" : \"admin\" }\r\n>\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Create Account Form\r\n\r\nWe will now create a new account form so that potential users can sign up for an account and start using our app. We will create `account_create.html` under `templates` directory.\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<h2>create account</h2>\r\n<form action=\"/account/create/submit\" method=\"post\" id=\"account-create-form\">\r\n    <div>\r\n        <input type=\"text\" name=\"username\" id=\"username\">\r\n        <label for=\"username\">username</label>\r\n        <input type=\"password\" name=\"password\" id=\"password\">\r\n        <label for=\"password\">password</label>\r\n        <input type=\"password\" name=\"confirm-password\" id=\"confirm-password\">\r\n        <label for=\"confirm-password\">confirm password</label>\r\n        <input type=\"submit\" name=\"new-account-submit\" id=\"new-account-submit\" value=\"submit\" class=\"button\">\r\n    </div>\r\n</form>\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n<script src=\"{{ static_url('js/account.js') }}\"></script>\r\n{% end %}\r\n```\r\n\r\nAs usual, we will `{% extends \"base.html\" %}` and write our new account form within `{% block content %}`. We will create 3 fields for our purpose: `username`, `password` and `confirm-password`. The purpose of the `confirm-password` field is just to make sure the user has typed in the correct password, which we will validate using Javascript from `js/account.js` that we include at the end. Our form will `post` to `/account/create/submit` if the validation is successful.\r\n\r\nWe also change our `base.html` template to use the `/acccount/create` URL for `Sign Up`:\r\n\r\n```\r\n<p><a href=\"/account/create\" class=\"button\">Sign Up</a>&nbsp;<a href=\"/login\" class=\"button\">Log In</a></p>\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Create Account Script\r\n\r\nNow we create the Javascript that will handle the create account form submission. Create a new file `account.js` under `static/js` directory.\r\n\r\n```\r\n$(document).ready(function() {\r\n    $('#new-account-submit').click(function(e) {\r\n        if ($('#password').val() === $('#confirm-password').val()) {\r\n            $('#account-create-form').submit();\r\n        } else {\r\n            e.preventDefault();\r\n            alert('Password and Confirm Password do not match!');\r\n        }\r\n    });\r\n});\r\n```\r\n\r\nFor our Javascript, we will first take the `password` field value and match with `confirm-password` field value. If they match, we simply call `submit` function of the `account-create-form`.\r\n\r\nHowever, if they don't match, we need to specifically call `e.preventDefault` so that the form submission will not happen. Then, we need to alert the user with a prompt, so that he can change the 2 password fields and make sure they match. \r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## After Create Account\r\n\r\nWe will also create the views that are displayed after successfully creating an account, or when the account is not created, perhaps due to duplicate username. Let's call them `account_success.html` and `account_error.html`.\r\n\r\n### `account_success.html`\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<p>Your account has been created successfully. Please login at <a href=\"/login\">Login Page</a> to start creating your list!</p>\r\n{% end %}\r\n```\r\n\r\nThere is nothing special in this page. We just `{% extends \"base.html\" %}` and then tell the user the account is created, and point to the Login Page.\r\n\r\n### `account_error.html`\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<p>Error in creating your account. {% if reason %}{{ reason }}{% end %}</p>\r\n<p>Please try again <a href=\"/account/create\">here</a></p>\r\n{% end %}\r\n```\r\n\r\nFor the error page, there's an additional Python expression that checks for `reason` and display if it exists. Then we point to the New Account page again.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Create Account Handler and URL Mapping\r\n\r\nWe now create the handlers to handle the `get` and `post` requests of the account page, using a new file `account.py` under `handlers`.\r\n\r\n```\r\nimport tornado.web\r\nimport hashlib\r\n\r\n\r\nclass AccountHandler(tornado.web.RequestHandler):\r\n    def initialize(self, db):\r\n        self.db = db\r\n\r\n    def get(self):\r\n        self.render(\"account_create.html\")\r\n\r\n    def post(self):\r\n        username = self.get_body_argument(\"username\")\r\n        password = self.get_body_argument(\"password\")\r\n        if username and password:\r\n            users = self.db['users']\r\n            if users.find_one({'username': username}):\r\n                self.render(\"account_error.html\", reason=\"User already exists\")\r\n            else:\r\n                hashed_pass = hashlib.md5(password.encode(\"utf-8\")).hexdigest()\r\n                users.insert_one({'username': username, 'password': hashed_pass, 'is_admin': False, 'is_active': True})\r\n                self.render(\"account_success.html\")\r\n        else:\r\n            self.render(\"account_error.html\", reason=\"Invalid username or password\")\r\n```\r\n\r\nLet's break this down. For the `get` function, it is just to render the `account_create.html` template. For the `post` function, we will first get the arguments `username` and `password` by calling `self.get_body_argument`. This will return us the values entered into the create account form.\r\n\r\nWe should always check that the `username` and `password` are not empty, then we will try to check whether the `username` already exists by calling `find_one` from our `users` collection. If it already exists, we will render the `account_error.html` template and pass in the `reason`. Otherwise,  we will hash the password using the `md5` algorithm from `hashlib` module. It is required by the hashing algorithm to encode our string, so we will call `encode(\"utf-8\")` from the `password` string before passing it into the `md5` function. Finally, we get the hashed string by calling `hexdigest`, which will return us a string in hexadecimal digits. This hashed password together with the username will be inserted by calling `users.insert_one`. Note that we will set `is_admin` as `False` and `is_active` as `True` for the time being. Later when we add on an advanced feature to deal with locking user account, we can make use of the `is_active` attribute.\r\n\r\nFinally, if we check that both `username` and `password` are empty, we will render the `account_error.html` template and pass in the `reason`.\r\n\r\nThe URLs mapping will be defined in `urls.py` as such:\r\n\r\n```\r\nfrom handlers.account import AccountHandler\r\n```\r\n\r\nFirst, we import the `AccountHandler` from `handlers.account`.\r\n\r\n```\r\nurl(r\"/account/create\", AccountHandler, dict(db=db)),\r\nurl(r\"/account/create/submit\", AccountHandler, dict(db=db)),\r\n```\r\n\r\nThen we map `/account/create` and `/account/create/submit` to the `AccountHandler`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Authenticate User with Password\r\n\r\nNow that we have created `password` in our user accounts, we can change our authentication logic to validate login password against the database.\r\n\r\nFirst, we need to make some changes to our `login.html` template.\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<form id=\"login-form\">\r\n    <div>\r\n        <input type=\"text\" name=\"username\" id=\"username\">\r\n        <label for=\"username\">Username</label>\r\n        <input type=\"password\" name=\"password\" id=\"password\">\r\n        <label for=\"password\">Password</label>\r\n    </div>\r\n    <input type=\"submit\" id=\"login-submit\" value=\"Login\" class=\"button\">\r\n</form>\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n<script src=\"{{ static_url('js/login.js') }}\"></script>\r\n{% end %}\r\n```\r\n\r\n*It's worth noting that we are now moving towards using AJAX for form submit, because we want to implement a REST-like server that returns JSON response. We will only use `<a>` tag for getting rendered response. Let's start refactoring our code from the authentication module, and we will refactor the rest of the application whenever necessary.* \r\n\r\nWe have removed the `action` and `method` attributes of the `form`, instead, we will use AJAX to post the form data to the server, we are going to include the jQuery scripts and a new `js/login.js` file.\r\n\r\nIn the new `js/login.js` file, we will bind a function to the `login-submit` button's `click` event:\r\n\r\n```\r\n$(document).ready(function() {\r\n    $('#login-submit').click(function(e) {\r\n        e.preventDefault();\r\n        var username = $('#username').val();\r\n        var password = $('#password').val();\r\n        if (username && password) {\r\n            $.ajax({\r\n                type: \"POST\",\r\n                url: \"/login/submit\",\r\n                dataType: \"json\",\r\n                data: {\"username\":username, \"password\":password},\r\n                success: function(response) {\r\n                    if (response) {\r\n                        if (response.status != 200 && response.errorMsg) {\r\n                            alert(response.errorMsg || \"Unable to login\");\r\n                        }\r\n                        if (response.redirectUrl) {\r\n                            window.location.href = response.redirectUrl;\r\n                        }\r\n                    }\r\n                },\r\n            });\r\n        } else {\r\n            alert(\"Please enter both username and password\");\r\n        }\r\n    });\r\n});\r\n```\r\n\r\nSince we are not going to do the traditional form submit, we will need to prevent the form submission by calling `e.preventDefault`. Then, we will extract the `username` and `password` fields, check that they are not empty and make the AJAX call to `/login/submit` with the `username` and `password` as form data. Upon successful request, we will get the `response` object and check the `status` code. If it is not `200`, we will try to display the `errorMsg`. If a `redirectUrl` is provided, we will redirect our page to the given URL.\r\n\r\nWe also try to validate that the `username` and `password` fields are entered, so we will prompt an error message for failing to enter either field, and we will not attempt to post the login details in this case.\r\n\r\nNext, let's change our `handlers/auth.py` file to reflect the logic:\r\n\r\n```\r\nimport tornado.web\r\nimport json\r\nimport hashlib\r\n\r\n\r\nclass LoginHandler(tornado.web.RequestHandler):\r\n    # omitted code here\r\n    def get(self):\r\n        self.render(\"login.html\")\r\n\r\n    def post(self):\r\n        username = self.get_body_argument(\"username\")\r\n        password = self.get_body_argument(\"password\")\r\n        users = self.db['users']\r\n        response = {}\r\n        if username and password:\r\n            user = users.find_one({'username': username})\r\n            if user:\r\n                stored_pass = user['password']\r\n                hashed_pass = hashlib.md5(password.encode(\"utf-8\")).hexdigest()\r\n                if hashed_pass == stored_pass:\r\n                    self.set_secure_cookie(\"user\", username)\r\n                    response['status'] = 200\r\n                    response['redirectUrl'] = \"/list\"\r\n                    self.write(json.dumps(response))\r\n                else:\r\n                    response['status'] = 403\r\n                    response['errorMsg'] = \"Invalid username or password\"\r\n                    response['redirectUrl'] = \"/login\"\r\n                    self.write(json.dumps(response))\r\n            else:\r\n                response['status'] = 403\r\n                response['errorMsg'] = \"Invalid username or password\"\r\n                response['redirectUrl'] = \"/login\"\r\n                self.write(json.dumps(response))\r\n        else:\r\n            response['status'] = 403\r\n            response['errorMsg'] = \"Invalid username or password\"\r\n            response['redirectUrl'] = \"/login\"\r\n            self.write(json.dumps(response))\r\n```\r\n\r\nWe have a new `import hashlib` which will be in charge of hashing passwords.\r\n\r\nThere are quite a few changes in our `post` function. Now that we will validate the login username and password against the database, we will need to extract both fields from the request body by calling `self.get_body_argument`. We then get the `users` collection from `self.db`, and try to find the document with matching `username`. If the it is found, then we hash the `password` from the request body by using `hashlib.md5(password.encode(\"utf-8\")).hexdigest` function. If this hashed password matches the password from the database, then we can set the user in our session cookie by `self.set_secure_cookie(\"user\", username)`. For successful authentication, we return `response['status'] = 200` and `response['redirectUrl'] = \"/list\"`. To write the JSON response, we call `json.dumps(response)` and pass to `self.write`.\r\n\r\nIf the username or password is not provided, or if the username does not match any in our database, or if the password does not match, then we will return `response['status'] = 403`, `response['errorMsg'] = \"Invalid username or password\"` and `response['redirectUrl'] = \"/login\"`. `403` status code indicates `Forbidden`, and we provide a human-friendly error message `Invalid username or password`, then redirect the client back to `/login` URL.\r\n\r\nSince we are refactoring our authentication module, let's also do some housekeeping on our logout AJAX call to make it consistent with our login AJAX call.\r\n\r\n### `static/js/main.js`\r\n\r\n```\r\n$(document).ready(function() {\r\n    $('#logout-btn').click(function() {\r\n        $.ajax({\r\n            type: \"POST\",\r\n            url: \"/logout\",\r\n            dataType: \"json\",\r\n            data: {},\r\n            success: function(response) {\r\n                if (response) {\r\n                    if (response.status != 200 && response.errorMsg) {\r\n                        alert(response.errorMsg || \"Error logging out\");\r\n                    }\r\n                    if (response.redirectUrl) {\r\n                        window.location.href = response.redirectUrl;\r\n                    }\r\n                }\r\n            },\r\n        });\r\n    }); \r\n});\r\n```\r\n\r\nThe logic is the same as before, only difference is that we specify the `dataType` to be `json` so that we don't have to `JSON.parse` the response. We also check that there is a `redirectUrl` and set the `window.location.href` accordingly.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Revisit List and User Authentication\r\n\r\nNow that we have introduced the concept of an user account, we should revisit our list data structure and incorporate the concept of ownership for each list.\r\n\r\nIf we look at our previously defined `lists` collection, it is just a list of `item`s with `text` and `color`. However, this does not serve our purpose well. \r\n\r\nWe will have to redefine our `lists` collection and assign a `username` to indicate ownership. Then we will create a separate collection just for `list_items`, and link back to the `lists` by the `lists`'s `_id`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Redefine List Collection\r\n\r\nFirst of all, let's remove the existing documents in the `lists` collection.\r\n\r\n```\r\n> mongo\r\nMongoDB shell version: 3.2.6\r\nconnecting to: test\r\n> use coloredlistdb\r\nswitched to db coloredlistdb\r\n> db.lists.remove({})\r\nWriteResult({ \"nRemoved\" : 5 })\r\n> db.lists.find()\r\n>\r\n```\r\n\r\nWe will call up the MongoDB shell, switch to `coloredlistdb`, then run the `db.lists.remove` command. The `lists` collection should now be empty.\r\n\r\nThen we will define a new data structure for our `lists` collection as such:\r\n\r\n```\r\n> db.lists.insert({\r\n... list_name: \"Default\",\r\n... username: \"admin\",\r\n... share_link: \"\",\r\n... })\r\nWriteResult({ \"nInserted\" : 1 })\r\n> db.lists.find()\r\n{ \"_id\" : ObjectId(\"572d8d3909d5ea66b520225f\"), \"list_name\" : \"Default\", \"username\" : \"admin\", \"share_link\" : \"\" }\r\n>\r\n```\r\n\r\nWe will let user name each list and store it in `list_name`. `username` will indicate that this list belongs to the username specified, for the time being, we will assign it to our `admin` user that we have created earlier. We will also have a `share_link` for publicly-accessible read-only view of the list.\r\n\r\nNext, we will define a new collection `list_items` that will store the actual list item details.\r\n\r\n```\r\n> db.createCollection(\"list_items\")\r\n{ \"ok\" : 1 }\r\n> db.list_items.insert({\r\n... \"list_id\":ObjectId(\"572d8d3909d5ea66b520225f\"),\r\n... \"text\":\"Walk the dog\",\r\n... \"color\":\"Red\",\r\n... \"status\":\"open\",\r\n... })\r\nWriteResult({ \"nInserted\" : 1 })\r\n>\r\n```\r\n\r\nOur `list_items` will have a link to the `lists` collection through the `list_id`. Then we put back the `text` and `color` fields from our previous definition. Finally, we add a new field `status` to indicate the status of the item, the default value is `open`.\r\n\r\nWe will insert 2 more default items with the same data structure and now our list should have the following items.\r\n\r\n```\r\n> db.list_items.find()\r\n{ \"_id\" : ObjectId(\"572d903e3f9d3719da74684b\"), \"list_id\" : ObjectId(\"572d8d3909d5ea66b520225f\"), \"text\" : \"Walk the dog\", \"color\" : \"Red\", \"status\" : \"open\" }\r\n{ \"_id\" : ObjectId(\"572d90f03f9d3719da74684c\"), \"list_id\" : ObjectId(\"572d8d3909d5ea66b520225f\"), \"text\" : \"Pick up dry cleaning\", \"color\" : \"Blue\", \"status\" : \"open\" }\r\n{ \"_id\" : ObjectId(\"572d91053f9d3719da74684d\"), \"list_id\" : ObjectId(\"572d8d3909d5ea66b520225f\"), \"text\" : \"Milk\", \"color\" : \"Green\", \"status\" : \"open\" }\r\n>\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Create Default List for New User\r\n\r\nNow that we have redefined our `lists` data strucutre, we need to link it up with our `users` in the create account logic.\r\n\r\n```\r\ndef post(self):\r\n    username = self.get_body_argument(\"username\")\r\n    password = self.get_body_argument(\"password\")\r\n    response = {}\r\n    if username and password:\r\n        users = self.db['users']\r\n        lists = self.db['lists']\r\n        if users.find_one({'username': username}):\r\n            response['status'] = 400\r\n            response['errorMsg'] = \"User already exists\"\r\n            response['redirectUrl'] = \"/account/create\"\r\n            self.write(json.dumps(response))\r\n        else:\r\n            hashed_pass = hashlib.md5(password.encode(\"utf-8\")).hexdigest()\r\n            users.insert_one({'username': username, 'password': hashed_pass, 'is_admin': False, 'is_active': True})\r\n            lists.insert_one({'list_name':\"Default\", 'username': username, 'share_link': \"\"})\r\n            self.set_secure_cookie(\"user\", username)\r\n            response['status'] = 201\r\n            response['redirectUrl'] = \"/list\"\r\n            self.write(json.dumps(response))\r\n    else:\r\n        response['status'] = 400\r\n        response['errorMsg'] = \"Invalid username or password\"\r\n        response['redirectUrl'] = \"/account/create\"\r\n        self.write(json.dumps(response))\r\n```\r\n\r\nInside `handlers/account.py`, we will change the `post` function to add in the logic to create a default list for the new user. This is done by getting the `lists` collection from `self.db`, then perform a `lists.insert_one` with the `username` field being set to the new `username` from the sign up. We will also add the user directly in the session, and redirect to the `/list` page instead of showing them the `account_success.html` page.\r\n\r\nNow, all new accounts will be assigned a default list and the users can immediately add new items to a list without having to login.\r\n\r\nSimilarly, if the account creation failed, we redirect them to the `/account/create` page with an error message, instead of showing them the `account_error.html` page, so that they can directly enter a new username without having to click a link to go back to the new account page.\r\n\r\nWith this change, we can remove `account_success.html` and `account_error.html` from `templates` directory.\r\n\r\nAs we change our back-end into a REST-like function, we also need to change our client `static/js/account.js`.\r\n\r\n```\r\n$(document).ready(function() {\r\n    $('#new-account-submit').click(function(e) {\r\n        e.preventDefault();\r\n        var username = $('#username').val();\r\n        var password = $('#password').val();\r\n        var confirm_password = $('#confirm-password').val();\r\n        if (username && password && confirm_password) {\r\n            if (password === confirm_password) {\r\n                $.ajax({\r\n                    type: \"POST\",\r\n                    url: \"/account/create/submit\",\r\n                    dataType: \"json\",\r\n                    data: {\"username\": username, \"password\": password},\r\n                    success: function(response) {\r\n                        if (response) {\r\n                            if (response.status != 201 && response.errorMsg) {\r\n                                alert(response.errorMsg || \"Failed to create account\");\r\n                            }\r\n                            if (response.redirectUrl) {\r\n                                window.location.href = response.redirectUrl;\r\n                            }\r\n                        }\r\n                    },\r\n                });\r\n            } else {\r\n                alert(\"Password and Confirm Password do not match!\");\r\n            }\r\n        } else {\r\n            alert(\"Username, password and confirm password should not be empty\");\r\n        }\r\n    });\r\n});\r\n```\r\n\r\nInstead of the default form action, we will attach a function to the `new-account-submit`'s `click` event. We will call `e.preventDefault` to stop the submit action and use AJAX call to send a `POST` request to `/account/create/submit` with the `username` and `password` as data. Upon success, we will display any `errorMsg` and redirect to `redirectUrl` whenever available.\r\n\r\nWe should help users type the correct password by making sure the `password` and `confirm-password` fields match, or we will prmopt a message. To make sure we do not send empty `username` and `password`, we should prompt a message if the fields are empty.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Authenticate User and Load List\r\n\r\nNow that we have linked up the user account with a list, we should load the correct list for each user who is authenticated successfully. When user has logged in and we redirect to the `/list` page, we need to get the corresponding list from the database.\r\n\r\nFor that, let's change our `handlers/list.py` file:\r\n\r\n```\r\ndef get(self):\r\n    username = self.get_secure_cookie(\"user\").decode(\"utf-8\") if self.get_secure_cookie(\"user\") else None\r\n    if username:\r\n        lists = self.db['lists']\r\n        list_items = self.db['list_items']\r\n        user_list = lists.find_one({'username': username})\r\n        items = []\r\n        if user_list:\r\n            list_id = user_list['_id']\r\n            self.set_secure_cookie(\"list_id\", str(list_id))\r\n            items_cursor = list_items.find({'list_id': list_id})\r\n            if items_cursor is not None:\r\n                items = [item for item in items_cursor]\r\n        self.render(\"list.html\", items=items)\r\n    else:\r\n        self.render(\"login.html\")\r\n```\r\n\r\nIn the `get` function, we will get the `username` from session, then try to find the corresponding list by calling `lists.find_one({'username': username})`. If it is found, we will store the `list_id` in session, then retrieve the list of items from `list_items.find({'list_id': list_id})` and set to `items` variable in the `list.html` template.\r\n\r\nIn any case that the user has been logged out, we will simply render the `login.html` page so that the user can re-login to access the list.\r\n\r\nOn the other hand, if the user is no longer logged in, we should also remove the `list_id` from the secure_cookie store by changing the `LogoutHandler`:\r\n\r\n```\r\ndef post(self):\r\n    response = {}\r\n    if self.get_secure_cookie(\"user\"):\r\n        self.set_secure_cookie(\"user\", \"\")\r\n        self.set_secure_cookie(\"list_id\", \"\")\r\n        response['status'] = 200\r\n        response['redirectUrl'] = \"/login\"\r\n        self.write(json.dumps(response))\r\n    else:\r\n        self.set_secure_cookie(\"list_id\", \"\")\r\n        response['status'] = 400\r\n        response['errorMsg'] = \"User not in session\"\r\n        response['redirectUrl'] = \"/login\"\r\n        self.write(json.dumps(response))\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Revisit List Item Operations\r\n\r\nSince our list data structure has changed, we should also revisit our list operations.\r\n\r\n### Add New Item\r\n\r\nTo store a new item to the `list_items` collection, we need to change our `handlers/list.py` file:\r\n\r\n```\r\ndef post(self):\r\n    username = self.get_secure_cookie(\"user\").decode(\"utf-8\") if self.get_secure_cookie(\"user\") else None\r\n    response = {}\r\n    if username:\r\n        lists = self.db['lists']\r\n        list_items = self.db['list_items']\r\n        text = self.get_body_argument(\"text\")\r\n        if text:\r\n            list_id = self.get_secure_cookie(\"list_id\").decode(\"utf-8\") if self.get_secure_cookie(\"list_id\") else None\r\n            if list_id:\r\n                list_items.insert_one({'list_id': ObjectId(list_id), 'text':text, 'color':\"Blue\", 'status':\"Open\"})\r\n        response['status'] = 201\r\n        response['redirectUrl'] = \"/list\"\r\n        self.write(json.dumps(response))\r\n    else:\r\n        response['status'] = 403\r\n        response['errorMsg'] = \"Please login to access your list\"\r\n        response['redirectUrl'] = \"/login\"\r\n        self.write(json.dumps(response))\r\n```\r\n\r\nWe need to make sure the user is in session by calling `self.get_secure_cookie(\"user\")` and make sure it exists. Then we will retrieve the user's list by using the `list_id` in `self.get_seccure_cookie`, create a new list item using the given `text` in `self.get_body_argument(\"text\")` and call `list_items.insert_one` to add the item to the list. If it's all successful, we will return `response['status'] = 201` and `response['redirectUrl'] = \"/list\"` to indicate `Created` status and let the client redirect to the list to reflect the change.\r\n\r\nIf the user is no longer in session, we will need to return `response['status'] = 403` for `Forbidden`, provide the appropriate `response['errorMsg'] = \"Please login to access your list\"` message, and `response['redirectUrl'] = \"/login\"` will allow the client to redirect to login page.\r\n\r\nWe will refactor the function to use AJAX call in the front-end and handle the JSON response from the back-end. First, in our `templates/list.html`, we will remove the `action` and `method` attributes from the `add-new` form.\r\n\r\n```\r\n<form id=\"add-new\">\r\n    <div>\r\n        <input type=\"text\" id=\"new-list-item-text\" name=\"text\">\r\n        <input type=\"submit\" id=\"new-item-submit\" value=\"Add\" class=\"button\">\r\n    </div>\r\n</form>\r\n```\r\n\r\nThen we modify the `static/js/list.js` file to make the AJAX call for sending the new item data:\r\n\r\n```\r\n$('#new-item-submit').click(function(e) {\r\n    e.preventDefault();\r\n    var text = $('#new-list-item-text').val();\r\n    if (text) {\r\n        var url = \"/list/create\";\r\n        $.ajax({\r\n            type: \"POST\",\r\n            url: url,\r\n            dataType: \"json\",\r\n            data: {\"text\": text},\r\n            success: function(response) {\r\n                if (response) {\r\n                    if (response.status != 201 && response.errorMsg) {\r\n                        alert(response.errorMsg || \"Create item failed\");\r\n                    }\r\n                    if (response.redirectUrl) {\r\n                        window.location.href = response.redirectUrl;\r\n                    }\r\n                }\r\n            },\r\n        });\r\n    } else {\r\n        alert(\"Item text should not be empty.\");\r\n    }\r\n});\r\n```\r\n\r\nAs with other AJAX calls, we will stop the default submit action by calling `e.preventDefault`, then `post` a request to `/list/create` with the `text` data. Upon success, we try to display any `errorMsg` and redirect to `redirectUrl` whenever available. If the `text` is empty, we will not attempt to send the request, but prompt an error message instead.\r\n\r\n### Edit List Item\r\n\r\nFor edit function, it will be a little complicated due to a handful of validations to be done.\r\n\r\n```\r\ndef put(self, item_id):\r\n    username = self.get_secure_cookie(\"user\").decode(\"utf-8\") if self.get_secure_cookie(\"user\") else None\r\n    response = {}\r\n    if username:\r\n        lists = self.db['lists']\r\n        list_items = self.db['list_items']\r\n        text = self.get_body_argument(\"text\")\r\n        if text:\r\n            list_id = self.get_secure_cookie(\"list_id\").decode(\"utf-8\") if self.get_secure_cookie(\"list_id\") else None\r\n            if list_id:\r\n                item = list_items.find({'_id': ObjectId(item_id)})\r\n                if item:\r\n                    list_items.update_one({'_id':ObjectId(item_id)}, {'$set':{'text':text}})\r\n                    response['status'] = 200\r\n                    response['redirectUrl'] = \"/list\"\r\n                    self.write(json.dumps(response))\r\n                else:\r\n                    response['status'] = 404\r\n                    response['errorMsg'] = \"Item not found\"\r\n                    response['redirectUrl'] = \"/list\"\r\n                    self.write(json.dumps(response))\r\n            else:\r\n                response['status'] = 404\r\n                response['errorMsg'] = \"List not in session. Please re-login\"\r\n                response['redirectUrl'] = \"/login\"\r\n                self.write(json.dumps(response))\r\n        else:\r\n            response['status'] = 400\r\n            response['errorMsg'] = \"Empty list item text\"\r\n            response['redirectUrl'] = \"/list\"\r\n            self.write(json.dumps(response))\r\n    else:\r\n        response['status'] = 403\r\n        response['errorMsg'] = \"Please login to access your list\"\r\n        response['redirectUrl'] = \"/login\"\r\n        self.write(json.dumps(response))\r\n```\r\n\r\nIn our `handlers/list.py` file, we will change the `put` function to make use of the new list data structure. To make sure the request is genuine, we check that the `username` is in `self.get_secure_cookie(\"user\")` and return `response['status'] = 403` if it is not. We also need to make sure the `text` is not empty, and will return `response['status'] = 400` if it is. Just in case the `list_id` is not found in `self.get_secure_cookie(\"list_id\")`, we will return `response['status'] = 404` as well. Finally we will validate the `item_id` actually exists in the database by calling `list_items.find` with the `item_id`, and will return `response['status'] = 404` if no item is found. After all the various validations, we can finally call `list_items.update_one` and pass in the `{'$set':{'text':text}}` as the modification to apply. This will return `response['status'] = 200` to indicate `OK` status.\r\n\r\nFor `user` and `list_id` not found in `self.get_secure_cookie`, it means that the user is no longer logged in, and we should return `response['redirectUrl'] = \"/login\"` so that the client can redirect to the login page for user to re-login. Otherwise, we will just return `response['redirectUrl'] = \"/list\"` for the client to refresh the list page.\r\n\r\nWe also change our `static/js/list.js` file to handle the new REST-like JSON response from the server.\r\n\r\n```\r\n$('.edit-button').click(function() {\r\n    var itemSpan = $(this).parent();\r\n    var itemId = $(itemSpan).find(\"input[type='hidden']\").val();\r\n    var text = $(itemSpan).find(\"input[name='text']\").val();\r\n    if (text) {\r\n        var url = \"/list/\" + itemId + \"/edit\";\r\n        $.ajax({\r\n            type: \"PUT\",\r\n            url: url,\r\n            dataType: \"json\",\r\n            data: {\"text\": text},\r\n            success: function(response) {\r\n                if (response) {\r\n                    if (response.status != 200 && response.errorMsg) {\r\n                        alert(response.errorMsg || \"Update item failed\");\r\n                    }\r\n                    if (response.redirectUrl) {\r\n                        window.location.href = response.redirectUrl;\r\n                    }\r\n                }\r\n            },\r\n        });\r\n    } else {\r\n        alert(\"Item text should not be empty.\");\r\n    }\r\n});\r\n```\r\n\r\nWe will check that the `text` field is not empty, then send a `PUT` request to `/list/<itemid>/edit` with `text` data. Upon success, we will display any `errorMsg` and redirect to `redirectUrl` whenever available.\r\n\r\n### Delete List Item\r\n\r\nThe delete logic will be similar to the edit logic, except that instead of calling `list_items.update_one`, we will call `list_items.remove`.\r\n\r\n```\r\ndef delete(self, item_id):\r\n    username = self.get_secure_cookie(\"user\").decode(\"utf-8\") if self.get_secure_cookie(\"user\") else None\r\n    response = {}\r\n    if username:\r\n        lists = self.db['lists']\r\n        list_items = self.db['list_items']\r\n        list_id = self.get_secure_cookie(\"list_id\").decode(\"utf-8\") if self.get_secure_cookie(\"list_id\") else None\r\n        if list_id:\r\n            item = list_items.find({'_id': ObjectId(item_id)})\r\n            if item:\r\n                list_items.remove({'_id':ObjectId(item_id)})\r\n                response['status'] = 200\r\n                response['redirectUrl'] = \"/list\"\r\n                self.write(json.dumps(response))\r\n            else:\r\n                response['status'] = 404\r\n                response['errorMsg'] = \"Item not found\"\r\n                response['redirectUrl'] = \"/list\"\r\n                self.write(json.dumps(response))\r\n        else:\r\n            response['status'] = 404\r\n            response['errorMsg'] = \"List not in session. Please re-login\"\r\n            response['redirectUrl'] = \"/login\"\r\n            self.write(json.dumps(response))\r\n    else:\r\n        response['status'] = 403\r\n        response['errorMsg'] = \"Please login to access your list\"\r\n        response['redirectUrl'] = \"/login\"\r\n        self.write(json.dumps(response))\r\n```\r\n\r\nThere is no need to validate `text` input here. We just need to make sure the `user` and `list_id` are still in `self.get_secure_cookie`, and the `item_id` exists in the database, then we can `list_items.remove` the item.\r\n\r\nOur `static/js/list.js` file will also be modified:\r\n\r\n```\r\n$('.delete-button').click(function() {\r\n    var itemSpan = $(this).parent();\r\n    var itemId = $(itemSpan).find(\"input[type='hidden']\").val();\r\n    var url = \"/list/\" + itemId + \"/delete\";\r\n    $.ajax({\r\n        type: \"DELETE\",\r\n        url: url,\r\n        dataType: \"json\",\r\n        data: {},\r\n        success: function(response) {\r\n            if (response) {\r\n                if (response.status != 200 && response.errorMsg) {\r\n                    alert(response.errorMsg || \"Delete item failed\");\r\n                }\r\n                if (response.redirectUrl) {\r\n                    window.location.href = response.redirectUrl;\r\n                }\r\n            }\r\n        },\r\n    });\r\n});\r\n```\r\n\r\nYou can see that it is similar in structure as the edit function, except that we don't need to pass the `text` field as data to the request.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Refactoring the App\r\n\r\nSo far our handler classes have been inheriting directly from `tornado.web.RequestHandler`. This means that all the handlers will use the default behaviour provided by the class, but sometimes we want to customize things to suit our needs. In this case, it is better to write a `BaseHandler` that inherits from `tornado.web.RequestHandler`, and override certain functions to customize the behaviour, then all our handlers will inherit from `BaseHandler` all the customized functions.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Base Handler\r\n\r\nYou might have noticed that we have a few places where we call `self.get_secure_cookie(\"user\").decode(\"utf-8\")` or `self.set_secure_cookie(\"user\", user)`. It gets a little lengthy after a while. Also, if we somehow decide to add additional logic when getting the current user, we have to change all places using `self.get_secure_cookie(\"user\").decode(\"utf-8\")`. A better approach will be to override `get_current_user` of `tornado.web.RequestHandler` in our `BaseHandler`. On top of that, we also create some shortcut functions to get the current session information. \r\n\r\nFirst, we will create a new `handlers/base.py` file.\r\n\r\n```\r\nimport tornado.web\r\nimport json\r\n\r\n\r\nclass BaseHandler(tornado.web.RequestHandler):\r\n    def initialize(self, db):\r\n        self.db = db\r\n\r\n    def get_current_session(self):\r\n        return self.get_current_user(), self.get_current_list()\r\n\r\n    def set_current_session(self, user, list_id):\r\n        self.set_secure_cookie(\"user\", user)\r\n        self.set_secure_cookie(\"list_id\", list_id)\r\n\r\n    def clear_current_session(self):\r\n        self.set_current_session(\"\", \"\")\r\n\r\n    def get_current_user(self):\r\n        return self.get_secure_cookie(\"user\").decode(\"utf-8\")\r\n\r\n    def set_current_user(self, user):\r\n        self.set_secure_cookie(\"user\", user)\r\n\r\n    def get_current_list(self):\r\n        return self.get_secure_cookie(\"list_id\").decode(\"utf-8\")\r\n\r\n    def set_current_list(self, list_id):\r\n        self.set_secure_cookie(\"list_id\", str(list_id))\r\n```\r\n\r\nIn this new file, we will create a `BaseHandler` class that extends `tornado.web.RequestHandler`. The class should be initialized with a `db` object. We will have functions that deal with session values.\r\n\r\n`get_current_session` is created as a shortcut to retrieve current session's `user` and `list_id` in a tuple. This is so that we don't need to call `get_current_user` and `get_current_list` separately. Corresponding to getting the current session, we also have a convenient function to `set_current_session`. Sometimes, we need to clear session data at once, and it's easier to do it with `clear_current_session`.\r\n\r\nHowever, sometimes we might just need either `user` or `list_id` from the session, so we still have individual `get_current_user` and `get_current_list` functions and their setter counterparts.\r\n\r\n### `urls.py`\r\n\r\nSince we are extending from `BaseHandler`, we need to always provide the `db` object to the class. We have to change `urls.py` accordingly for `MainHandler`.\r\n\r\n```\r\nurl(r\"/\", MainHandler, dict(db=db)),\r\n```\r\n\r\n### `handlers/main.py`\r\n\r\nWe will show one example of how to change the handlers to extend `BaseHandler`.\r\n\r\n```\r\nfrom handlers.base import BaseHandler\r\n\r\nclass MainHandler(BaseHandler):\r\n    def initialize(self, db):\r\n        super().initialize(db)\r\n```\r\n\r\nFor example, in our `handlers/main.py`, we will change the parent class of `MainHandler` to `BaseHandler`, and we call `super().initialize(db)` instead of directly setting `self.db = db` as previously done.\r\n\r\nBesides, we also need to change all the `self.get_secure_cookie(\"user\")` to `self.get_current_user()`.\r\n\r\nThe other handlers should follow the same style as in `main.py`:\r\n\r\n1. Import base handler class by `from handlers.base import BaseHandler`\r\n2. Extend `BaseHandler` and call `super().initialize(db)`\r\n3. Change all `self.set_secure_cookie(\"user\", username)` to `self.set_current_user(username)`\r\n4. Change all `self.get_secure_cookie(\"user\")` to `self.get_current_user()`\r\n5. Change all `self.set_secure_cookie(\"list_id\", list_id)` to `self.set_current_list(list_id)`\r\n6. Change all `self.get_secure_cookie(\"list_id\")` to `self.get_current_list()`\r\n\r\nIn places where we need both `user` and `list_id`, we can call the `username,list_id = self.get_current_session()` to get both values at once.\r\n\r\n### `LogoutHandler`\r\n\r\n```\r\ndef post(self):\r\n    if self.get_current_user():\r\n        self.clear_current_session()\r\n```\r\n\r\nIn our `LogoutHandler`, we also change to use `self.clear_current_session` so that we don't have to call `self.set_current_user(\"\")` and `self.set_current_list(\"\")`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Write Response\r\n\r\n*EDIT: After reading more about error handling and consulting my mentor, I realized that my previous approach was not quite the standard practice. Thus, I have decided to revise this tutorial to make it more acceptable. It may still not be the best practice, but I believe it is better than how I did it previously. With this incident also proves that having the `BaseHandler` handles the response and errors, and a `base.js` to handle the response is one of the best decisions I have made. It makes my revision so much easier. This is a revised version of the tutorial. For the previous version, please refer to [commit d71f9dfa875c4c4b98be83ae97fa259b911bc6c7](https://github.com/gohkhoonhiang/coloredlist/commit/d71f9dfa875c4c4b98be83ae97fa259b911bc6c7).*\r\n\r\nOther than session values, another function that we call frequently is `self.write`, and we pass in a `response` object with attributes such as `status` and `errorMsg`. Instead of having to create the `response` object everytime we need to write a response, why not we provide a common function in the `BaseHandler` that takes in just the `status` and `errorMsg`, and will take care of creating the `response` and `write` it?\r\n\r\n```\r\ndef write_response(self, status_code, **kwargs):\r\n    response = {}\r\n    response['status'] = status_code\r\n    response['errorMsg'] = kwargs['errorMsg'] if 'errorMsg' in kwargs else None\r\n    self.set_status(status_code)\r\n    self.write(json.dumps(response))\r\n\r\ndef write_response_ok(self, **kwargs):\r\n    self.write_response(200, **kwargs)\r\n    \r\ndef write_response_created(self, **kwargs):\r\n    self.write_response(201, **kwargs)\r\n    \r\ndef write_response_bad(self, **kwargs):\r\n    self.write_response(400, **kwargs)\r\n        \r\ndef write_response_forbidden(self, **kwargs):\r\n    kwargs['redirectUrl'] = \"/login\"\r\n    self.write_response(403, **kwargs)\r\n\r\ndef write_response_not_found(self, **kwargs):\r\n    self.write_response(404, **kwargs)\r\n```\r\n\r\nLet's revisit the `BaseHandler` class. We will add a few more functions that deal with writing response. A base `write_response` function will take a required `status_code` argument, and a list of keyword arguments, then create a `response` object. By default it must set the `status` attribute, then if `errorMsg` is found in the keyword arguments, they will be added to the `response` accordingly. We will also properly set the response status code using `self.set_status(status_code)` so that the client can handle the response as an `error`. Finally, it will call `json.dumps(response)` and `self.write` to write the response in JSON format.\r\n\r\nWe provide a few commonly used status response, such as `200`, `201`, `400`, `403` and `404`. These functions do not take the `status_code`, instead it is set accordingly based on the purpose of the function. For example, the `write_response_ok` function will set `200` when calling `write_response`, then the `**kwargs` will be passed to `write_response` as-is.\r\n\r\n### `account.py`\r\n\r\nLet's look at an example of how to make use of the `BaseHandler`'s `write` functions.\r\n\r\n```\r\nif users.find_one({'username': username}):\r\n    self.write_response_bad(errorMsg=\"User already exists\")\r\n```\r\n\r\nIn our `AccountHandler`, somewhere in the `post` function we have the code to `self.write(json.dumps(response))`. We can now replace this with just `self.write_response_bad(errorMsg=\"User already exists\")`.\r\n\r\nThe rest of our handlers will follow the same pattern, calling the respective `write_response` according to status and passing the `errorMsg` and `redirectUrl` keyword arguments when necessary.\r\n\r\n[Back to top](#table-of-contents)\r\n  \r\n## Error Handling\r\n\r\nSo far we have been seeing a plain text error message page that prints all the stack trace to the user. We don't actually want users to see the internals of our application, instead, we should customize a pretty page that gracefully shows an error message about the error.\r\n\r\nTo achieve that, we will need to override `write_error` function of `tornado.web.RequestHandler`, and create a custom `error.html` template to display the error message. \r\n\r\nBesides, we should also provide a custom `404.html` page that is displayed when the user request for a resource that does not exist.\r\n\r\n### `BaseHandler`\r\n\r\n```\r\ndef write_error(self, status_code, **kwargs):\r\n    if 'exc_info' in kwargs:\r\n        err_cls, err, traceback = kwargs['exc_info']\r\n    errorMsg = err if err else \"\"\r\n    self.render(\"error.html\", code=status_code, message=errorMsg)\r\n```\r\n\r\nIn our `BaseHandler`, we will override `write_error` function. In the [official docs](http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write_error), it is mentioned that if the `write_error` is caused by an uncaught exception, a `exc_info` tuple will be available in `kwargs`. This tuple contains the error class, the error message and the stack trace of the error. For our error page, we only need to output the simple error message, so we will take the 2nd value in the tuple and return as `message` for rendering. \r\n\r\nThen we create the `templates/error.html` to display the error message.\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<div class=\"alert alert-danger\" role=\"alert\">An error has occurred!{% if message %}<br>{{ message }}{% end %}</div>\r\n{% end %}\r\n```\r\n\r\n### `ErrorHandler`\r\n\r\nAnother common type of error encountered will be the famous `404` error. Instead of showing the default `404` page, we will create a custom `404` page for rendering.\r\n\r\nTo render that custom page, we will need to create a custom `ErrorHandler` class in the `handlers/base.py` file.\r\n\r\n```\r\nclass ErrorHandler(tornado.web.RequestHandler):\r\n    def prepare(self):\r\n        self.render(\"404.html\")\r\n```\r\n\r\nWe override the `prepare` function, which will be called before `get` or `post`. This allows us to intercept the requests where the resource is not available, and then render a `404.html` page.\r\n\r\nWe need to tell our application to use this custom `ErrorHandler` class by a special setting in `settings.py`.\r\n\r\n```\r\nfrom handlers.base import ErrorHandler\r\n\r\n### other codes omitted\r\n\r\nsettings['default_handler_class'] = ErrorHandler\r\n```\r\n\r\nUnder `settings`, we will add one more attribute `default_handler_class` and assign `ErrorHandler` class to it.\r\n\r\nFinally, we create `templates/404.html` that will display an error message when the user requests for a resource that does not exist.\r\n\r\n```\r\n{% extends \"base.html\" %}\r\n{% block content %}\r\n<div class=\"alert alert-danger\" role=\"alert\">Opps! The page you requested for has not been created. Go back to <a href=\"/\">home</a> and try again.<div>\r\n{% end %}\r\n```\r\n\r\n### `main.css`\r\n\r\nSince we have created new classes for displaying error messages, we must not forget to add the style to our `main.css`.\r\n\r\n```\r\n.alert { padding: 20px; width: 400px; border-radius: 5px; }\r\n.alert-danger { background-color: #e33; color: #eee; }\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Modular Templating\r\n\r\nOur templates structure is still not quite streamlined. You would have noticed that we are including the jQuery library in every template file that we create, which is not the way to go. Oue goal is to only include the jQuery library once and be used by all sub-templates. To do so, we need to do some housekeeping on the `templates/base.html` file.\r\n\r\n### Scripts\r\n\r\nBefore that, let's create a `templates/scripts.html` file.\r\n\r\n```\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n<script src=\"{{ static_url('js/main.js') }}\"></script>\r\n```\r\n\r\nWe will include the jQuery library, `base.js` and `main.js` in this file. This file allows us to add more common scripts later without having to change every other script files.\r\n\r\n```\r\n{% include \"scripts.html\" %}\r\n{% block scripts %}\r\n{% end %}\r\n```\r\n\r\nWe then declare `{% include \"scripts.html\" %}` in the `base.html` file. We also declare a `{% block scripts %}` which is used by sub-templates to include their own individual scripts.\r\n\r\n```\r\n{% block scripts %}\r\n<script src=\"{{ static_url('js/account.js') }}\"></script>\r\n{% end %}\r\n```\r\n\r\nFor example, in our `account_create.html`, we will declare `{% block scripts %}` and include the `<script>` tag for `account.js`.\r\n\r\n### Styles\r\n\r\nWe also have a similar problem with our stylesheets, so we should also create a `templates/styles.html` file that includes all common style sheets.\r\n\r\n```\r\n<link rel=\"stylesheet\" href=\"{{ static_url('css/main.css') }}\">\r\n<link rel=\"stylesheet\" href=\"{{ static_url('css/sidebar.css') }}\">\r\n```\r\n\r\nThen we will `{% include \"styles.html\" %}` in `templates/base.html`, and also declare `{% block styles %}` for sub-templates to include their own stylesheets.\r\n\r\n```\r\n<title>Colored List App</title>\r\n{% include \"styles.html\" %}\r\n{% block styles %}\r\n{% end %}\r\n```\r\n\r\nTo make use of this, we will change our `templates/list.html` file, and include the `<script>` tag for `list.css` inside the `{% block styles %}`.\r\n\r\n```\r\n{% block styles %}\r\n<link rel=\"stylesheet\" href=\"{{ static_url('css/list.css') }}\">\r\n{% end %}\r\n```\r\n\r\n### Header, Sidebar and Footer\r\n\r\nTo keep the `base.html` as simple and short as possible, I thought it would be good to extract the header, sidebar and footer into separate templates, and then include them in the `base.html`. This is so that when the either of these sections grow, the `base.html` will not get too complicated to read.\r\n\r\nWe will create `templates/header.html`, `templates/sidebar.html` and `templates/footer.html` files, and declare `{% include \"header.html\" %}`, `{% include \"sidebar.html\" %}` and `{% include \"footer.html\" %}` in their right places.\r\n\r\n```\r\n<div id=\"page-wrap\">\r\n    {% include \"header.html\" %}\r\n    {% include \"sidebar.html\" %}\r\n    <div id=\"main\">\r\n    {% block content %}\r\n    {% end %}\r\n    </div>\r\n</div>\r\n{% include \"scripts.html\" %}\r\n{% block scripts %}\r\n{% end %}\r\n{% include \"footer.html\" %}\r\n```\r\n\r\n### `header.html`\r\n\r\n```\r\n<div id=\"header\">\r\n    <h1><a href=\"/\">Colored List App</a></h1>\r\n    <div id=\"control\">\r\n        <p><a href=\"#\" id=\"logout-btn\" class=\"button\">Log Out</a>&nbsp;<a href=\"/account\" class=\"button\">Your Account</a></p>\r\n        <p><a href=\"/account/create\" class=\"button\">Sign Up</a>&nbsp;<a href=\"/login\" class=\"button\">Log In</a></p>\r\n    </div>\r\n</div>\r\n```\r\n\r\n### `sidebar.html`\r\n\r\n```\r\n<div id=\"ribbon\">\r\n    Reminders\r\n    <ul>\r\n        <li>Your list automatically saves</li>\r\n        <li>Double-click list items to edit them</li>\r\n    </ul>\r\n</div>\r\n```\r\n\r\n### `footer.html`\r\n\r\n```\r\n<div class=\"footer\">\r\n    <span>&copy; 2016 Coloredlist App</span>\r\n</div>\r\n```\r\n\r\nFor styling the footer, we will include `.footer { text-align: center; bottom: 20px; }` in `static/css/main.css`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Common Javascript\r\n\r\nWe have refactored our templates, let's also refactor our Javascripts. As this is mainly a Tornado tutorial, I will not go into using frontend frameworks eg. AngularJS, instead, I will just create simple base Javascripts using jQuery.\r\n\r\nFirst, we will create a `static/js/base.js` file.\r\n\r\n```\r\nfunction sendRequest(type, url, data, successUrl, errorUrl) {\r\n    $.ajax({\r\n        type: type,\r\n        url: url,\r\n        dataType: \"json\",\r\n        data: data,\r\n        success: function(response) {\r\n            handleResponse(response);\r\n            redirect(successUrl);\r\n        },\r\n        error: function(response) {\r\n            handleResponse(response);\r\n            if (response.status == 403) {\r\n                redirect(\"/login\");\r\n            } else {\r\n                redirect(errorUrl);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\nfunction getRequest(url, data, successUrl, errorUrl) {\r\n    sendRequest(\"GET\", url, data, successUrl, errorUrl);\r\n}\r\n\r\nfunction postRequest(url, data, successUrl, errorUrl) {\r\n    sendRequest(\"POST\", url, data, successUrl, errorUrl);\r\n}\r\n\r\nfunction putRequest(url, data, successUrl, errorUrl) {\r\n    sendRequest(\"PUT\", url, data, successUrl, errorUrl);\r\n}\r\n\r\nfunction deleteRequest(url, data, successUrl, errorUrl) {\r\n    sendRequest(\"DELETE\", url, data, successUrl, errorUrl);\r\n}\r\n\r\nfunction redirect(url) {\r\n    if (url) {\r\n        window.location.href = url;\r\n    }\r\n}\r\n\r\nfunction alertError(errorMsg) {\r\n    alert(errorMsg || \"An error has occurred\");\r\n}\r\n\r\nfunction handleResponse(response) {\r\n    if (response && response.responseJSON) {\r\n        if (response.responseJSON.errorMsg) {\r\n            alertError(response.responseJSON.errorMsg);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWe have been calling `$.ajax` everywhere in our various frontend scripts, and we want to simplify that using a base function. For each of the `get`, `post`, `put` and `delete` methods, we will create a wrapper function that takes `url` and `data` arguments, and together with the HTTP method, the arguments are passed to the base `sendRequest` function.\r\n\r\nIn the base `sendRequest` function, we will call the actual jQuery's `$.ajax`, and handle the response using a common `handleResponse` function. In the AJAX callback, we will handle 2 cases: `success` and `error`. On `success` response, we will handle the response and redirect to the `successUrl` given by the caller. Otherwise, we will check whether the status is `403`, if it is, then we will redirect to `/login` immediately; else we will redirect to the `errorUrl` given by the caller. I'm not sure if this is a standard practice, but it seems okay to me at this point. Perhaps when I read up more in the future, I will need to rewrite this part again.\r\n\r\nWe also have wrapper functions for displaying `alert` and redirecting URLs, so that we don't have to keep checking for empty values.\r\n\r\nNow that we have the `base.js` file, we want to include it in every page of our application. To do so, we just include `<script src=\"{{ static_url('js/base.js') }}\"></script>` in the `templates/scripts.html` file.\r\n\r\nLet's look at how we can call the base function to send request to the server.\r\n\r\n```\r\n$('#new-item-submit').click(function(e) {\r\n    e.preventDefault();\r\n    var text = $('#new-list-item-text').val();\r\n    if (text) {\r\n        var url = \"/list/create\";\r\n        var data = {\"text\":text};\r\n        postRequest(url, data, \"/list\", \"/list\");\r\n    } else {\r\n        alertError(\"Item text should not be empty.\");\r\n    }\r\n});\r\n```\r\n\r\nFor example, in our `static/js/list.js` file, we will replace the `$.ajax` function with just the simple `postRequest` function, passing in `url`, `data` and \"/list\" as both `successUrl` and `errorUrl` as arguments. It will then take care of sending the request using the appropriate HTTP method, and will handle the response and redirect if any. This will apply to all the other scripts that make use of `$.ajax` call.\r\n\r\nBesides, you would notice that we are calling `alertError` instead of `alert` function. This allows us to customize how we want to display our error message, instead of being hardcoded to using the Javascript `alert` function.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}