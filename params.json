{
  "name": "Coloredlist",
  "tagline": "A Tornado Tutorial App",
  "body": "### Table of Contents\r\n\r\n* [Introduction](#introduction)\r\n* [Getting Started](#getting-started)\r\n  * [Virtual Environment](#virtual-environment)\r\n  * [Installing Packages](#installing-packages)\r\n* [Creating the App](#creating-the-app)\r\n  * [The Main Application](#the-main-application)\r\n  * [Templates](#templates)\r\n* [Creating the List](#creating-the-list)\r\n  * [List URL Mapping](#list-url-mapping)\r\n  * [In Memory Storage](#in-memory-storage)\r\n  * [Import UUID](#import-uuid)\r\n  * [List Template](#list-template)\r\n  * [List Handler](#list-handler)\r\n* [Edit and Delete List Items](#edit-and-delete-list-items)\r\n  * [List Item URL Mapping](#list-item-url-mapping)\r\n  * [List Item Handler](#list-item-handler)\r\n  * [Importing Javascript](#importing-javascript)\r\n  * [Edit Template](#edit-template)\r\n  * [AJAX](#ajax)\r\n\r\n\r\n# Introduction\r\n\r\nThis is a prototype as part of learning Tornado framework. The idea and design of the app is based off [here](https://css-tricks.com/app-from-scratch-1-design/).\r\n\r\nI will attempt to write the README in tutorial style, as how I taught myself doing it from various sources.\r\n\r\nI will also try to commit the README and source code in accordance to the progress of the application.\r\n\r\nHopefully this will make it easier to follow the README and source code at different stages.\r\n\r\n*Please feel free to file issues regarding the README if you find something inaccurate or unclear about the explanation. This is my first time writing a public tutorial and I have a lot to learn from anyone of you who care enough to read this. Thank you so much for your support.*\r\n\r\n*Also, please do file issues regarding the actual source code if you find the code does not comply with certain standards or if improvements are needed. I am still new to python and there will surely be coding style which I have not followed.*\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Getting Started\r\n\r\n## Virtual Environment\r\n\r\nAs this is a python-based app, it is recommended to use `virtualenv` to contain the necessary packages for this project only.\r\n\r\nRun `pip install virtualenv` to install `virtualenv` if you don't already have the package.\r\n\r\nIn the directory you have created for this project, run the command `virtualenv venv` to create the directory for the new environment. Replace `venv` with any name you wish.\r\n\r\n*If you want to use python3 for the project, run `virtualenv -p python3 venv` instead. Make sure you already have python3 installed.*\r\n\r\nTo activate the environment, run the command `. venv/bin/activate` in the directory you have created `venv` directory.\r\n\r\nYou should see that your command prompt has `(venv)` in the prefix.\r\n\r\nYou can read more about `virtualenv` [here](https://virtualenv.readthedocs.org).\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Installing Packages\r\n\r\nThe packages required for getting started with developing this app is included in the `requirements.txt` file.\r\n\r\nRun `pip install -r requirements.txt` to install the packages.\r\n\r\nYou can read more about python package installation [here](https://pip.pypa.io/en/stable/user_guide/).\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Creating the App\r\n\r\n## The Main Application\r\n\r\nWe will start with a `app.py` file, which contains the basics of the application we want to create.\r\n\r\nFor now, we will not care about the application structure. Our goal here is just to get it to work.\r\n\r\nWe need to import some packages from the `tornado` framework.\r\n\r\n```\r\nimport tornado.ioloop\r\nimport tornado.web\r\nfrom tornado.web import url\r\n```\r\n\r\nWe will use a function to create the application instead of writing it directly in the main code.\r\n\r\n```\r\ndef make_app():\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n    ],\r\n    debug=True)\r\n```\r\n\r\nWe first define the main page URL and its handler. Whenever the client requests for `http://server:port/`, the `MainHandler` will handle the request and send the appropriate response.\r\n\r\nThe `debug=True` setting is to run the application in debug mode.\r\n\r\nNow we will define the `MainHandler`.\r\n\r\n```\r\nclass MainHandler(tornado.web.RequestHandler):\r\n    def get(self):\r\n        self.write('''<!DOCTYPE html>    \r\n                    <html>\r\n                    <head>\r\n                        <title>Colored List App</title>\r\n                    </head>\r\n                    <body>\r\n                        <div id=\"page-wrap\">\r\n                            <div id=\"header\">\r\n                                <h1><a href=\"/\">Colored List App</a></h1>\r\n                                <div id=\"control\">\r\n                                    <p><a href=\"/logout\" class=\"button\">Log Out</a>&nbsp;<a href=\"/account\" class=\"button\">Your Account</a></p>\r\n                                    <p><a href=\"/signup\" class=\"button\">Sign Up</a>&nbsp;<a href=\"/login\" class=\"button\">Log In</a></p>\r\n                                </div>\r\n                            </div>\r\n                            <div id=\"ribbon\">\r\n                                Reminders\r\n                                <ul>\r\n                                    <li>Your list automatically saves</li>\r\n                                    <li>Double-click list items to edit them</li>\r\n                                </ul>\r\n                            </div>\r\n                            <div id=\"main\">\r\n                            </div>\r\n                        </div>\r\n                    </body>\r\n                    </html>''')\r\n```\r\n\r\nWhen the client requests for `http://server:port/`, it will be sent as a `GET` request, so this will be handled by the `MainHandler`'s `get` function.\r\n\r\nWe will serve a HTML page as the response.\r\n\r\nNotice that I have injected some CSS classes and defined some IDs in the HTML elements. We will come to styling later.\r\n\r\nIn order for the server to run, we need to define the main entry code.\r\n\r\n```\r\nif __name__ == '__main__':\r\n    app = make_app()\r\n    app.listen(9080)\r\n    tornado.ioloop.IOLoop.current().start()\r\n```\r\n\r\nWe need to create an instance of the application by calling the `make_app()` function. Then I make it listen to port 9080. You can choose whichever port you wish.\r\n\r\nThe server is started by `tornado.ioloop.IOLoop.current().start()`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Templates\r\n\r\nIt is a little messy to write the HTML code directly in the `MainHandler`'s `get` function. We will try to take this code out into a proper HTML file, and get the handler to render the HTML file.\r\n\r\nWe first create the `main.html` file and put the exact HTML code into this file.\r\n\r\n```\r\n<!DOCTYPE html>    \r\n<html>\r\n<head>\r\n    <title>Colored List App</title>\r\n</head>\r\n<body>\r\n    <div id=\"page-wrap\">\r\n        <div id=\"header\">\r\n            <h1><a href=\"/\">Colored List App</a></h1>\r\n            <div id=\"control\">\r\n                <p><a href=\"/logout\" class=\"button\">Log Out</a>&nbsp;<a href=\"/account\" class=\"button\">Your Account</a></p>\r\n                <p><a href=\"/signup\" class=\"button\">Sign Up</a>&nbsp;<a href=\"/login\" class=\"button\">Log In</a></p>\r\n            </div>\r\n        </div>\r\n        <div id=\"ribbon\">\r\n            Reminders\r\n            <ul>\r\n                <li>Your list automatically saves</li>\r\n                <li>Double-click list items to edit them</li>\r\n            </ul>\r\n        </div>\r\n        <div id=\"main\">\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\nTo render this HTML file, we use the `render` method of the `RequestHandler` class.\r\n\r\nWe replace the `get` method we wrote earlier with the following:\r\n\r\n```\r\ndef get(self):\r\n    self.render(\"main.html\")\r\n```\r\n\r\nNow the code looks much cleaner as we separate the view out of the logic code.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Creating the List\r\n\r\nWe now have a basic structure application. It's time to start creating the list itself.\r\n\r\nWe will start with just 2 simple functionalities for the list.\r\n* View the list\r\n* Create a list item\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List URL Mapping\r\n\r\nFor each of the functionalities above, we will design endpoints for the client to send the requests to.\r\n\r\nIn the `make_app()` method we created earlier, we will add a few more `URLSpec` objects for each endpoint.\r\n\r\n```\r\ndef make_app():\r\n    return tornado.web.Application([\r\n        url(r\"/\", MainHandler),\r\n        url(r\"/list/create\", ListHandler),\r\n        url(r\"/list\", ListHandler),\r\n    ],\r\n    debug=True)\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## In Memory Storage\r\n\r\nFor the time being, we will not use a persistent database for storage. Instead, we will create a in-memory storage for our list items.\r\n\r\nWe will come to using persistent storage at a later stage. For now, our purpose is to get the logic working.\r\n\r\nWe declare a global variable `list_items` that we will use as a in-memory storage for all the list items.\r\n\r\nWe will define it as a dictionary where the item ID will be the key and the item definition is another dictionary that forms the value paired with the key.\r\n\r\n```\r\nlist_items = {\r\n    \"1\":{\"id\":\"1\",\"text\":\"Walk the dog\",\"color\":\"Red\"},\r\n    \"2\":{\"id\":\"2\",\"text\":\"Pick up dry cleaning\",\"color\":\"Blue\"},\r\n    \"3\":{\"id\":\"3\",\"text\":\"Milk\",\"color\":\"Green\"},\r\n}\r\n```\r\n\r\nWe initialize some data first that we can display in the front-end.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Import UUID\r\n\r\nFor the purpose of using `uuid` to generate a unique ID for each item, we need to remember to import the `uuid` module.\r\n\r\n```\r\nimport uuid\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Template\r\n\r\nTo help us visualize the data, let's create the `list.html` template file first.\r\n\r\n```\r\n<ul>\r\n{% for item_id in items %}\r\n    <li class=\"{{ items[item_id][\"color\"] }}\">\r\n        <span>{{ items[item_id]['text'] }}</span>\r\n    </li>\r\n{% end %}\r\n</ul>\r\n\r\n<form action=\"/list/create\" method=\"post\">\r\n    <div>\r\n        <input type=\"text\" id=\"new-list-item-text\" name=\"text\">\r\n        <input type=\"submit\" id=\"new-item-submit\" value=\"Add\" class=\"button\">\r\n    </div>\r\n</form>\r\n```\r\n\r\nNotice something different is happening in this template. We have injected some python code in this template to help us display the list items.\r\n\r\nSince we are going to have a list of items, it is logical to have a loop control to display each item. This is where we use the `{% for item_id in items %}` construct.\r\n\r\nIn our in-memory store, we use the item ID as the key for the item definition itself, so in order to access the item data, we will need to get the item dictionary and then the attribute.\r\n\r\nFor example, we will use `{{ items[item_id][\"text\"] }}` to retrieve the text of the item with a specific `item_id`.\r\n\r\nWe have not added all the `<head>` and `<body>` tags in this template, because we are going to make use of template inheritance later.\r\n\r\nFor now we just want to make sure the data are displayed correctly with this structure.\r\n\r\nThis template should display a list of items in storage, and also provide a form to allow creating a new item which will be added to the in-memory storage.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Handler\r\n\r\nWe will not use the `MainHandler` for handling requests pertaining to the list. Instead, we will create a new `ListHandler` class for this purpose.\r\n\r\nFor each of the functionalities, we assign a method in the `ListHandler` according to the HTTP method we allow for access.\r\n\r\n```\r\nclass ListHandler(tornado.web.RequestHandler):\r\n    def get(self):\r\n        self.render(\"list.html\", items=list_items)\r\n\r\n    def post(self):\r\n        text = self.get_body_argument(\"text\")\r\n        item_id = str(uuid.uuid4())\r\n        list_items[item_id] = {\"id\":item_id,\"text\":text,\"color\":\"Blue\"}\r\n        self.redirect(\"/list\")\r\n```\r\nAs the client requests for `http://server:port/list`, the `ListHandler`'s `get` method will render the `list.html` page.\r\n\r\nIf the client enters some text in the form and hit the `Add` button, it will send a `POST` request containing the form data. The `ListHandler`'s `post` method will handle this request.\r\n\r\nFirst we will extract the text entered by the client by calling `self.get_body_argument(\"text\")`. Note that all form data are accessible by `self.get_body_argument` method by passing in the input name as the method parameter.\r\n\r\nWe will auto-generate a unique ID for this item by using `uuid.uuid4()` method.\r\n\r\nThen we create a new dictionary containing all the item data and add it to the in-memory `list_items` storage using the `item_id` as key.\r\n\r\nOnce we are done with the storage, we will redirect to the `/list` page so that the changes can be reflected to the user.\r\n\r\nWe will realize that the list items are not sorted according to the order they are created. For that, we will need to devise some data strucutre and logic to handle the sorting later.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n# Edit and Delete List Items\r\n\r\nA list without the edit or delete functions are almost useless. We will now add these functionalities to our list.\r\n\r\nThere can be a few ways to approach this problem.\r\n\r\n1. Continue using `ListHandler` and add the corresponding `put` and `delete` methods for editing and deleting list items.\r\n2. Create a separate `ListItemEditHandler` and `ListItemDeleteHandler` for editing and deleting list items.\r\n\r\nThe first approach will be more compact due to having only a single handler. The methods also clearly reflects the purpose of the request, mapping edit to `put` and delete to `delete` methods.\r\n\r\nHowever, we cannot simply use a form for editing and deleting, because HTML `<form>` does not support `put` and `delete` methods. We will need to use AJAX for these actions.\r\n\r\nThe second approach is more lengthy due to having to create 2 more handlers just for each of the actions.\r\n\r\nHowever, we can easily use a form to send a `post` request for each actions, and map to a `post` method within each handler.\r\n\r\nPersonally, I would prefer doing the first approach. I only need to main a single handler, while having the advantage of mapping the actions correctly to the methods: edit to `put` and delete to `delete`.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Item URL Mapping\r\n\r\nFor using the first approach, we will map the request URL as follows:\r\n\r\n```\r\nurl(r\"/list/([0-9a-zA-Z\\-]+)/edit\", ListHandler),\r\n```\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## List Item Handler\r\n\r\nSince it is an edit action, we will map it to the `put` method of the `ListHandler`.\r\n\r\n```\r\ndef put(self, item_id):\r\n    text = self.get_body_argument(\"text\")\r\n    item = None\r\n    try:\r\n        item = list_items[item_id]\r\n    except KeyError:\r\n        self.set_status(404)\r\n        self.finish(\"Not found\")\r\n        return\r\n    if item:\r\n        item[\"text\"] = text\r\n    self.set_status(200)\r\n    self.finish(\"OK\")\r\n    return\r\n```\r\n\r\nThe `item_id` is already provided as a path argument. We only need to extract the `text` data from the request body by calling `self.get_body_argument` method.\r\n\r\nTo do a little error handling, we will try to get the item data from the `list_items` dictionary, while catching `KeyError`.\r\n\r\nIf `KeyError` is raised, then we will return a status of `404` and message `Not found` to inform the client of the error.\r\n\r\nIf the item is found, then we just overwrite the `text` value.\r\n\r\nAt the end of it, we will return a status of `200` and message `OK` to inform the client that the edit is done.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Importing Javascript\r\n\r\nWe can write plain Javascript for the AJAX calls, but I decide that it is best to use existing libraries to make our life easier.\r\n\r\nWe will use jQuery to help with handling the AJAX calls, so we will include this following code in the `list.html` file.\r\n\r\n```\r\n<script src=\"https://code.jquery.com/jquery-2.2.3.min.js\" integrity=\"sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=\" crossorigin=\"anonymous\"></script>\r\n```\r\n\r\nWe will add this `<script>` tag at the end of the page so that it does not slow down the page loading.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## Edit Template\r\n\r\nThen, we will need to cater for editing by changing the `list.html` file. Previously we have a simple `<span>{{ items[item_id]['text'] }}</span>` to display the item text. Now we need to make it editable.\r\n\r\n```\r\n<span><input type=\"hidden\" id=\"edit-item-{{ item_id }}-id\" value=\"{{ item_id }}\"><input type=\"text\" id=\"edit-item-{{ item_id }}-text\" name=\"text\" value=\"{{ items[item_id]['text'] }}\"><a href=\"#\" id=\"edit-item-{{ item_id }}-submit\" class=\"button edit-button\">Edit</a></span>\r\n```\r\n\r\nWe have added a hidden field to store the `item_id`, put the item text in a text input field and created a link to submit the edit action.\r\n\r\nNote that we have created a unique ID for each input field as there may be multiple of such fields in the same list.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n## AJAX\r\n\r\nNow we have the fields ready, we need to add in the logic to send the data to the server.\r\n\r\nBelow the `<script>` tag that imports the jQuery source, we will create our customized Javascript that will perform the AJAX call.\r\n \r\n```\r\n<script type=\"text/javascript\">\r\n<script type=\"text/javascript\">\r\n$(document).ready(function() {\r\n    $('.edit-button').click(function() {\r\n        var itemSpan = $(this).parent();\r\n        var itemId = $(itemSpan).find(\"input[type='hidden']\").val();\r\n        var text = $(itemSpan).find(\"input[name='text']\").val();\r\n        var url = \"/list/\" + itemId + \"/edit\";\r\n        console.log(url);\r\n        $.ajax({\r\n            type: \"PUT\",\r\n            url: url,\r\n            dataType: \"json\",\r\n            data: {\"id\": itemId, \"text\": text},\r\n            statusCode: {\r\n                200: function(xhr) {\r\n                    alert(\"Item updated successfully\");\r\n                },\r\n                404: function(xhr) {\r\n                    alert(\"Item ID not found\");\r\n                },\r\n            },\r\n        });\r\n    });\r\n});\r\n</script>\r\n```\r\n\r\nThere is quite a lot going on in this segment of code.\r\n\r\nFirst, we attach the `click` event to all the elements with the class `edit-button`. In this case, it will be all the `<a>` tags for each list item.\r\n\r\nOnce the `click` event is triggered, we will try to extract the data we require.\r\n\r\nWe get the parent `<span>` containing the `<a>` being clicked. This allows us to extract the element containing the `item_id` and `text` of the item.\r\n\r\nOnce we have these data, we can now construct the URL and data for the AJAX call.\r\n\r\nSince we have defined a `put` method in the `ListHandler` to handle the edit function, we will set the call type to `PUT`. The data will be sent as a `json` data type and the data itself is constructed using the values from the input fields.\r\n\r\nOnce the server returns a response, we will display an alert to inform the status.\r\n\r\n[Back to top](#table-of-contents)\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}